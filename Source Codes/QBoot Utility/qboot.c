//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    char * e3;
    char * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _TYPEDEF_GUID {
    int32_t e0;
    int16_t e1;
    int16_t e2;
    char e3[8];
};

struct _SP_DEVINFO_DATA {
    int32_t e0;
    struct _TYPEDEF_GUID e1;
    int32_t e2;
    int32_t e3;
};

struct _TYPEDEF___mbstate_t {
    int32_t e0;
    int32_t e1;
};

struct lconv {
    char * e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char e10;
    char e11;
    char e12;
    char e13;
    char e14;
    char e15;
    char e16;
    char e17;
    char e18;
    char e19;
    char e20;
    char e21;
    char e22;
    char e23;
};

// ------------------- Function Prototypes --------------------

int32_t ___Balloc_D2A(int32_t a1);
int32_t ___Bfree_D2A(int32_t * a1);
int32_t ___do_global_dtors(void);
int32_t ___freedtoa(int32_t a1);
int32_t ___gcc_register_frame(int32_t a1);
int32_t ___i2b_D2A(int32_t a1);
int32_t ___main(void);
int32_t ___nrv_alloc_D2A(char * a1, int32_t * a2, int32_t a3);
int32_t ___pformat_emit_radix_point(int32_t a1);
int32_t ___pformat_putc(int32_t a1, int32_t a2);
int32_t ___rv_alloc_D2A(uint32_t a1);
int32_t ___trailz_D2A(int32_t a1);
int32_t __get_output_format(void);
int32_t _blank_flash_device(int32_t a1, int32_t a2, int32_t a3, struct _IO_FILE * a4, int32_t a5);
int32_t _dtoa_lock(int32_t a1);
int32_t _dtoa_lock_cleanup(void);
int32_t _dtoa_unlock(int32_t a1);
char * _extract_id(char * a1, char * str);
int32_t _getopt_long(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _getopt_long_only(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _getopt_parse(int32_t a1, int32_t a2, char * a3, char * a4, int32_t * a5, int32_t * a6, int32_t a7);
int32_t _list_devices(void);
int32_t _list_devices_callback(struct _IO_FILE * a1);
int32_t _match_device(int32_t a1);
int32_t _match_device_with_port(int32_t * a1, char * a2);
void _msleep(int32_t dwMilliseconds);
int32_t _on_event(int32_t a1, int32_t * a2);
int32_t _serial_enum_devices(char * hKey);
int32_t _usage(void);
int32_t _version(void);
int32_t _wait_for_device(void);
int32_t function_4027f7(int32_t a1);
int32_t function_402827(int32_t a1);
int32_t function_406191(void);
int32_t function_4063fa(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = -0x5cef3b7d; // 0x401b0d
int32_t g9 = -0x5cef3b7d; // 0x401b29
int32_t g10 = 0; // 0x408000
int32_t g11 = 0x407224; // 0x408004
int32_t g12 = 1; // 0x408010
int32_t g13 = 1; // 0x408014
char * g14 = "?"; // 0x408018
char * g16; // 0x408034
char (*g17)[5] = "port"; // 0x4095a0
int32_t g18 = 0; // 0x40a008
int32_t g19 = 0; // 0x40a018
struct _IO_FILE * g20 = NULL; // 0x40a028
int32_t g21 = 0; // 0x40a038
int32_t g22 = 0; // 0x40a03c
int32_t g23 = 0; // 0x40a040
int32_t g24 = 0; // 0x40a0c0
int32_t g25 = 0; // 0x40a158
int32_t g26 = 0; // 0x40a15c
int32_t g27 = 0; // 0x40a160
char * g28; // 0x40a170
int32_t g29 = 0; // 0x40a180
int32_t g30 = 0; // 0x40a190
char g31 = 0; // 0x40a1a0
void (**g32)() = NULL; // 0x40a1e0
struct _RTL_CRITICAL_SECTION * g33 = NULL; // 0x40a1f0
int32_t g34 = 0; // 0x40a220
int32_t g35 = 0; // 0x40a260
int32_t g36 = 0xb40a; // 0x40b1dc
int32_t * g15 = &g35; // 0x408030

// ------------------------ Functions -------------------------

// Address range: 0x401290 - 0x4012df
int32_t ___gcc_register_frame(int32_t a1) {
    int32_t v1;
    g2 = &v1;
    char * v2 = g16;
    int32_t result = (int32_t)v2;
    g1 = result;
    if (v2 == NULL) {
        // 0x4012da
        g2 = *(int32_t *)g2;
        return result;
    }
    char * moduleHandle = GetModuleHandleA("libgcj_s.dll"); // 0x4012a7
    g6 = (int32_t)moduleHandle;
    g1 = 0;
    if (moduleHandle == NULL) {
        // 0x4012da
        g2 = *(int32_t *)g2;
        return 0;
    }
    // 0x4012c9
    v1 = 0;
    int32_t (**func)() = GetProcAddress(moduleHandle, "_Jv_RegisterClasses"); // 0x4012c2
    g1 = (int32_t)func;
    g6 = 0;
    g4 = v1;
    int32_t result2; // 0x4012db_2
    if (func != NULL) {
        // 0x4012cd
        ((int32_t (*)(int32_t))func)((int32_t)&g16);
        result2 = g1;
        // branch -> 0x4012da
    } else {
        result2 = 0;
    }
    // 0x4012da
    g2 = *(int32_t *)g2;
    return result2;
}

// Address range: 0x4012f0 - 0x40131f
int32_t ___do_global_dtors(void) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = *(int32_t *)g11; // 0x4012fb
    if (v2 == 0) {
        // 0x401316
        return 0;
    }
    g1 = v2;
    ((int32_t (*)())v2)();
    int32_t v3 = g11 + 4; // 0x401308
    g11 = v3;
    int32_t v4 = *(int32_t *)v3; // 0x401310
    while (v4 != 0) {
        // 0x401301
        g1 = v4;
        ((int32_t (*)())v4)();
        v3 = g11 + 4;
        g11 = v3;
        v4 = *(int32_t *)v3;
        // continue -> 0x401301
    }
    // 0x401316
    // branch -> 0x401316
    // 0x401316
    return 0;
}

// Address range: 0x401320 - 0x40139f
int32_t ___main(void) {
    int32_t v1 = g7; // 0x401323
    int32_t v2 = g3; // 0x401324
    if (g10 != 0) {
        // 0x40132f
        g3 = v2;
        g7 = v1;
        return g1;
    }
    // 0x401336
    g3 = *(int32_t *)0x407218;
    g10 = 1;
    g1 = ___gcc_register_frame(v2);
    int32_t v3 = g3; // 0x40134b
    int32_t atexit_rc; // 0x401370
    int32_t v4; // 0x401354
    int32_t v5; // 0x401365
    int32_t v6; // 0x401354
    int32_t v7; // 0x401362
    if (v3 != -1) {
        v4 = v3;
        // 0x401350
        if (v4 == 0) {
            // 0x401368
            atexit_rc = atexit((void (**)())___do_global_dtors);
            g1 = atexit_rc;
            g3 = v2;
            g7 = v1;
            return atexit_rc;
        }
        // 0x401354
        v6 = 4 * v4 + 0x407218;
        g7 = v6;
        ((int32_t (*)())*(int32_t *)v6)();
        v7 = g7 - 4;
        g7 = v7;
        v5 = g3 - 1;
        g3 = v5;
        // branch -> 0x401360
        while (v5 != 0) {
            // 0x401360
            ((int32_t (*)())*(int32_t *)v7)();
            v7 = g7 - 4;
            g7 = v7;
            v5 = g3 - 1;
            g3 = v5;
            // continue -> 0x401360
        }
        // 0x401368
        atexit_rc = atexit((void (**)())___do_global_dtors);
        g1 = atexit_rc;
        g3 = v2;
        g7 = v1;
        return atexit_rc;
    }
    // 0x40137f
    if (*(int32_t *)0x40721c == 0) {
        // 0x401368
        atexit_rc = atexit((void (**)())___do_global_dtors);
        g1 = atexit_rc;
        g3 = v2;
        g7 = v1;
        return atexit_rc;
    }
    int32_t v8 = 1; // 0x401383
    g3 = v8;
    int32_t v9 = v8 + 1; // 0x401385
    g1 = v9;
    int32_t v10 = *(int32_t *)(4 * v9 + 0x407218); // 0x401388
    v4 = v8;
    while (v10 != 0) {
        // 0x401383
        g6 = v10;
        v8 = v9;
        g3 = v8;
        v9 = v8 + 1;
        g1 = v9;
        v10 = *(int32_t *)(4 * v9 + 0x407218);
        v4 = v8;
        // continue -> 0x401383
    }
    // 0x401350
    if (v4 == 0) {
        // 0x401368
        atexit_rc = atexit((void (**)())___do_global_dtors);
        g1 = atexit_rc;
        g3 = v2;
        g7 = v1;
        return atexit_rc;
    }
    // 0x401354
    v6 = 4 * v4 + 0x407218;
    g7 = v6;
    ((int32_t (*)())*(int32_t *)v6)();
    v7 = g7 - 4;
    g7 = v7;
    v5 = g3 - 1;
    g3 = v5;
    // branch -> 0x401360
    while (v5 != 0) {
        // 0x401360
        ((int32_t (*)())*(int32_t *)v7)();
        v7 = g7 - 4;
        g7 = v7;
        v5 = g3 - 1;
        g3 = v5;
        // continue -> 0x401360
    }
    // 0x401368
    atexit_rc = atexit((void (**)())___do_global_dtors);
    g1 = atexit_rc;
    g3 = v2;
    g7 = v1;
    return atexit_rc;
}

// Address range: 0x4013a0 - 0x401414
int32_t _version(void) {
    int32_t v1 = 0; // bp-8
    int32_t v2 = 0; // bp-12
    fprintf((struct _IO_FILE *)(g36 + 64), "Motorola qboot utility version %x.%x\n", 2, 4);
    int32_t v3 = &v1; // 0x4013d5_0
    g1 = v3;
    qb_get_version(v3, (int32_t)&v2);
    int32_t result = g1; // 0x4013e1
    if (result != 0) {
        // 0x401413
        return result;
    }
    int32_t result2; // 0x401414_2
    int32_t chars_printed;
    if (v1 == 2) {
        // 0x4013ed
        g1 = v2;
        if (v2 != 4) {
            // 0x4013f5
            chars_printed = fprintf((struct _IO_FILE *)(g36 + 64), "DLL version: %x.%x\n", v1, v2);
            g1 = chars_printed;
            result2 = chars_printed;
            // branch -> 0x401413
        } else {
            result2 = 4;
        }
    } else {
        // 0x4013f5
        chars_printed = fprintf((struct _IO_FILE *)(g36 + 64), "DLL version: %x.%x\n", v1, v2);
        g1 = chars_printed;
        result2 = chars_printed;
        // branch -> 0x401413
    }
    // 0x401413
    return result2;
}

// Address range: 0x401415 - 0x401439
int32_t _usage(void) {
    int32_t items_written = fwrite("usage: qboot [ <option> ] <command>\n\ncommands:\n  devices                                       list connected devices\n  blank-flash [ <programmer> [ <singleimage> ]] blank flash device\n\noptions:\n  -p <port>, --port=<port>  specify device port\n                            This is needed only when the program does not detect\n                            the device automatically or when multiple devices in\n                            blank flash mode are connected\n\n                            Set --port to be the full or any unambiguous part of\n                            a device pathname. For example:\n                            --port=100\n                            --port=COM100\n                            --port=ttyUSB3\n                            --port=/dev/ttyUSB3\n                            --port=/dev/tty.usbtoserial\n  --debug[=<level>]         enable debugging\n                            1(default): show debug messages\n                            2: also dump raw packets\n  -h, --help                show help screen\n  -v, --version             show version info\n\nexamples:\n  qboot devices             list all connected devices\n  qboot blank-flash         blank flash device\n", 1, 1196, (struct _IO_FILE *)(g36 + 64)); // 0x401430
    g1 = items_written;
    return items_written;
}

// Address range: 0x40143a - 0x401501
int32_t _on_event(int32_t a1, int32_t * a2) {
    // 0x40143a
    switch (a1) {
        case 0: {
            // 0x401457
            fprintf((struct _IO_FILE *)(g36 + 64), g18 == 0 ? "%s" : "\n%s");
            g18 = 0;
            // branch -> 0x4014fb
            break;
        }
        case 1: {
            int32_t v1 = *a2; // 0x40149f
            if ((int32_t)((0x100000000 * (int64_t)(v1 >> 31) || (int64_t)v1) % 10) == 0) {
                // 0x4014bb
                fprintf((struct _IO_FILE *)(g36 + 64), "%3d%%", v1);
                fwrite("\b\b\b\b", 1, 4, (struct _IO_FILE *)(g36 + 64));
                g18 = 1;
                // branch -> 0x4014fb
            }
            break;
        }
    }
    // 0x4014fb
    return 0;
}

// Address range: 0x401502 - 0x40155a
int32_t _blank_flash_device(int32_t a1, int32_t a2, int32_t a3, struct _IO_FILE * a4, int32_t a5) {
    // 0x401502
    qb_blank_flash(a1, a2, a3, (int32_t)_on_event, (int32_t)a4);
    if (g1 != 0) {
        // 0x40152d
        qb_describe_error(g1);
        fprintf((struct _IO_FILE *)(g36 + 64), "FAILED (%s)\n", (char *)g1);
        // branch -> 0x401556
    }
    // 0x401556
    return g1;
}

// Address range: 0x40155b - 0x4015ce
int32_t _match_device_with_port(int32_t * a1, char * a2) {
    int32_t v1 = (int32_t)a1;
    if (*a1 == 1478) {
        // 0x40156d
        if (*(int32_t *)(v1 + 4) == 0x9008) {
            char * v2 = (char *)(v1 + 136); // 0x40157d_0
            int32_t result; // 0x4015ca10
            if (((int32_t)*v2 || v1 & -256) != 0) {
                // 0x401590
                if (a2 != NULL) {
                    // 0x401596
                    if (((int32_t)*a2 || (int32_t)a2 & -256) != 0) {
                        // 0x40159f
                        if (strcasestr(v2, a2) == NULL) {
                            // 0x4015ca
                            return -1;
                        }
                    }
                }
                // 0x4015c3
                result = 0;
                // branch -> 0x4015ca
            } else {
                result = -1;
            }
            // 0x4015ca
            return result;
        }
    }
    // 0x4015ca
    return -1;
}

// Address range: 0x4015cf - 0x4015ea
int32_t _match_device(int32_t a1) {
    int32_t result = _match_device_with_port((int32_t *)a1, (char *)g19); // 0x4015e1
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x4015eb - 0x401670
int32_t _wait_for_device(void) {
    struct _IO_FILE * v1 = g20;
    struct _IO_FILE * v2 = v1;
    int32_t result;
    if (v1 == NULL) {
        int32_t v3 = _serial_enum_devices((char *)_match_device); // 0x40161325
        struct _IO_FILE * v4 = (struct _IO_FILE *)v3;
        g20 = v4;
        if (v3 == 0) {
            // 0x401639
            fwrite("< waiting for device >\n", 1, 23, (struct _IO_FILE *)(g36 + 64));
            _msleep(500);
            int32_t v5 = _serial_enum_devices((char *)_match_device); // 0x401613
            struct _IO_FILE * v6 = (struct _IO_FILE *)v5;
            g20 = v6;
            // branch -> 0x40165a
            while (v5 == 0) {
                // 0x40165a
                _msleep(500);
                v5 = _serial_enum_devices((char *)_match_device);
                v6 = (struct _IO_FILE *)v5;
                g20 = v6;
                // continue -> 0x40165a
            }
            // 0x40166c
            // branch -> 0x40166c
            // 0x40166c
            result = (int32_t)v6;
            g1 = result;
            return result;
        }
        // 0x40166c
        v2 = v4;
        // branch -> 0x40166c
    }
    // 0x40166c
    result = (int32_t)v2;
    g1 = result;
    return result;
}

// Address range: 0x401671 - 0x401686
void _msleep(int32_t dwMilliseconds) {
    // 0x401671
    Sleep(dwMilliseconds);
}

// Address range: 0x401687 - 0x4016e6
int32_t _list_devices_callback(struct _IO_FILE * a1) {
    // 0x401687
    if (_match_device_with_port(&a1->e0, NULL) == 0) {
        int32_t v1 = (int32_t)a1;
        char * v2 = (char *)(v1 + 8); // 0x4016a4_0
        unsigned char v3 = *v2; // 0x4016a4
        char * v4 = ((int32_t)v3 | v1 & -256) == 0 ? "QCOM emergency download" : v2; // 0x4016a4_0
        fprintf((struct _IO_FILE *)(g36 + 64), "%s \t\"%s\"\n", (char *)(v1 + 136), v4);
        // branch -> 0x4016e0
    }
    // 0x4016e0
    return -1;
}

// Address range: 0x4016e7 - 0x4016fe
int32_t _list_devices(void) {
    int32_t result = _serial_enum_devices((char *)_list_devices_callback); // 0x4016f5
    g1 = result;
    return result;
}

// Address range: 0x4016ff - 0x40193f
int main(int argc, char ** argv) {
    ___main();
    setvbuf((struct _IO_FILE *)(g36 + 64), NULL, 4, 0);
    int32_t * str = (int32_t *)((int32_t)&argc + 4); // 0x40174f_0
    int32_t v1 = 0;
    // branch -> 0x40173d
    while (true) {
        // 0x40173d
        // branch -> 0x40173d
        while (true) {
            int32_t v2 = *str; // 0x40174f
            int32_t v3 = _getopt_long(argc, v2, (int32_t)"p:d:hv", (int32_t)&g17, 0); // 0x401757
            if (v3 >= 0) {
                // 0x40176c
                if (v3 == 104) {
                    // 0x4017f7
                    _usage();
                    // branch -> 0x401934
                    // 0x401934
                    return 0;
                }
                // 0x401778
                if (v3 > 104) {
                    // 0x401793
                    switch (v3) {
                        case 112: {
                            // 0x4017a4
                            g19 = g25;
                            // branch -> 0x40173d
                            continue;
                        }
                        case 118: {
                            // 0x401808
                            _version();
                            // branch -> 0x401934
                            // 0x401934
                            return 0;
                        }
                    }
                    // 0x401825
                    abort();
                    // UNREACHABLE
                }
                // 0x40177e
                switch (v3) {
                    case 63: {
                        // 0x401934
                        return -1;
                    }
                    case 100: {
                        // 0x4017b0
                        if (g25 == 0) {
                          lab_0x4017e0:;
                            // 0x4017e0
                            // branch -> 0x4017e4
                        } else {
                            // 0x4017da
                            if (strtoul((char *)g25, NULL, 0) != 0) {
                                goto lab_0x4017e0;
                            }
                            // 0x4017e4
                            // branch -> 0x40173d
                            break;
                        }
                        // 0x4017e4
                        // branch -> 0x40173d
                        break;
                    }
                }
                // 0x401825
                abort();
                // UNREACHABLE
            }
            int32_t v4 = g12; // 0x40182a
            argc -= v4;
            *str = *str + 4 * v4;
            if (argc == 0) {
                // 0x40184a
                _usage();
                // branch -> 0x401934
                // 0x401934
                return -1;
            }
            // 0x40185b
            if (strcmp((char *)*(int32_t *)*str, "devices") == 0) {
                // 0x401878
                _list_devices();
                // branch -> 0x401934
                // 0x401934
                return 0;
            }
            // 0x401889
            g20 = (struct _IO_FILE *)_wait_for_device();
            if (strcmp((char *)*(int32_t *)*str, "blank-flash") != 0) {
                int32_t v5 = *(int32_t *)*str; // 0x40190c
                fprintf((struct _IO_FILE *)(g36 + 64), "Invalid command: %s\n", (char *)v5);
                _usage();
                // branch -> 0x401934
                // 0x401934
                return -1;
            }
            int32_t v6 = argc; // 0x4018c1
            int32_t result; // 0x4018f9
            int32_t v7;
            int32_t v8;
            if (v6 < 2) {
                // 0x4018d4
                // branch -> 0x4018ea
                // 0x4018ea
                v8 = (int32_t)g20;
                g1 = v8;
                result = _blank_flash_device(v8, 0, 0, (struct _IO_FILE *)v1, v7);
                // branch -> 0x401934
                // 0x401934
                return result;
            }
            int32_t v9 = *(int32_t *)(*str + 4); // 0x4018cf
            if (v6 >= 3) {
                int32_t v10 = *(int32_t *)(*str + 8); // 0x4018f242
                // branch -> 0x4018ea
                // 0x4018ea
                v8 = (int32_t)g20;
                g1 = v8;
                result = _blank_flash_device(v8, v9, v10, (struct _IO_FILE *)v1, v7);
                // branch -> 0x401934
                // 0x401934
                return result;
            }
            // 0x4018ea
            v8 = (int32_t)g20;
            g1 = v8;
            result = _blank_flash_device(v8, v9, 0, (struct _IO_FILE *)v1, v7);
            // branch -> 0x401934
            // 0x401934
            return result;
        }
    }
}

// Address range: 0x4019e4 - 0x401a35
char * _extract_id(char * a1, char * str) {
    char * v1 = strcasestr(a1, str); // 0x4019f3
    int32_t str_as_ul;
    if (v1 != NULL) {
        // 0x401a04
        str_as_ul = strtoul((char *)(strlen(str) + (int32_t)v1), NULL, 16);
        // branch -> 0x401a31
    } else {
        str_as_ul = 0;
    }
    // 0x401a31
    int32_t v2;
    g2 = v2;
    return (char *)str_as_ul;
}

// Address range: 0x401a36 - 0x401c77
int32_t _serial_enum_devices(char * hKey) {
    int32_t v1 = 0; // esp
    int32_t v2;
    int32_t v3 = &v2; // 0x401a39_3
    int32_t v4;
    int32_t v5 = &v4; // 0x401a54_0
    int32_t v6;
    if (SetupDiClassGuidsFromNameA("PORTS", (struct _TYPEDEF_GUID *)&v6, 1, &v4)) {
        char * v7 = SetupDiGetClassDevsA((struct _TYPEDEF_GUID *)&v6, NULL, NULL, 10); // 0x401a8c
        int32_t v8 = (int32_t)v7; // 0x401a8c_9
        int32_t result2; // 0x401c70
        if (v7 == (char *)-1) {
            // 0x401a97
            v2 = 0;
            result2 = 0;
            // branch -> 0x401c70
        } else {
            int32_t v9 = 28;
            int32_t v10 = &v9; // 0x401c1e_0
            int32_t v11;
            int32_t v12 = &v11; // 0x401ac9_0
            int32_t v13;
            int32_t v14 = &v13; // 0x401ba9_0
            bool v15 = SetupDiEnumDeviceInfo(v7, 0, (struct _SP_DEVINFO_DATA *)&v9); // 0x401c2b73
            int32_t v16 = v3; // 0x401c38
            int32_t result = 0; // 0x401c4837
            if (v15) {
                int32_t v17 = 1; // 0x401c1876
                // branch -> 0x401ab2
                while (true) {
                    // 0x401ab2
                    *(int32_t *)(v3 - 8) = 264;
                    *(int32_t *)(v3 - 12) = 0;
                    *(int32_t *)(v3 - 16) = (int32_t)&g21;
                    *(int32_t *)(v3 - 20) = 0x401ac6;
                    memset(hKey, 0, 0);
                    *(int32_t *)(v1 + 8) = v5;
                    int32_t * v18 = (int32_t *)(v1 + 4); // 0x401ad6_0
                    *v18 = 128;
                    int32_t * v19 = (int32_t *)v1; // 0x401adb_0
                    *v19 = v12;
                    int32_t * v20 = (int32_t *)(v1 - 4); // 0x401adc_0
                    *v20 = 0;
                    *(int32_t *)(v1 - 8) = 1;
                    *(int32_t *)(v1 - 12) = v10;
                    *(int32_t *)(v1 - 16) = v8;
                    *(int32_t *)(v1 - 20) = 0x401aee;
                    if (SetupDiGetDeviceRegistryPropertyA(hKey, NULL, 0, NULL, NULL, 0, NULL)) {
                        // 0x401af9
                        *v18 = (int32_t)"VID_";
                        *v19 = v12;
                        *v20 = (int32_t)&g8;
                        g21 = (int32_t)_extract_id(hKey, NULL);
                        *(int32_t *)(v1 + 4) = (int32_t)"PID_";
                        *(int32_t *)v1 = v12;
                        *(int32_t *)(v1 - 4) = (int32_t)&g9;
                        char * v21 = _extract_id(hKey, NULL); // 0x401b24
                        g22 = (int32_t)v21;
                        if (g21 != 0) {
                            // 0x401b3e
                            if (v21 != NULL) {
                                int32_t * v22 = (int32_t *)(v1 + 8); // 0x401b56_0
                                *v22 = v5;
                                int32_t * v23 = (int32_t *)(v1 + 4); // 0x401b57_0
                                *v23 = 128;
                                int32_t * v24 = (int32_t *)v1; // 0x401b5c_0
                                *v24 = (int32_t)&g23;
                                int32_t * v25 = (int32_t *)(v1 - 4); // 0x401b5d_0
                                *v25 = 0;
                                int32_t * v26 = (int32_t *)(v1 - 8); // 0x401b5f_0
                                *v26 = 12;
                                int32_t * v27 = (int32_t *)(v1 - 12); // 0x401b64_0
                                *v27 = v10;
                                int32_t * v28 = (int32_t *)(v1 - 16); // 0x401b65_0
                                *v28 = v8;
                                int32_t * v29 = (int32_t *)(v1 - 20); // 0x401b6d_1
                                *v29 = 0x401b6f;
                                if (SetupDiGetDeviceRegistryPropertyA(hKey, NULL, 0, NULL, NULL, 0, NULL)) {
                                    // 0x401b7a
                                    *v23 = 0x20019;
                                    *v24 = 1;
                                    *v25 = 0;
                                    *v26 = 1;
                                    *v27 = v10;
                                    *v28 = v8;
                                    *v29 = 0x401b96;
                                    char * v30 = SetupDiOpenDevRegKey(hKey, NULL, 0, 0, 0, 0); // 0x401b94
                                    int32_t v31 = (int32_t)v30; // 0x401b94_9
                                    if (v30 != (char *)-1) {
                                        // 0x401ba2
                                        v4 = 128;
                                        g6 = v5;
                                        *v23 = v5;
                                        *v24 = v14;
                                        *v25 = 0;
                                        *v26 = 0;
                                        *v27 = (int32_t)"PortName";
                                        *v28 = v31;
                                        *v29 = 0x401bc8;
                                        int32_t v32 = v1;
                                        if (RegQueryValueExA(hKey, NULL, NULL, NULL, NULL, NULL) == 0) {
                                            // 0x401bcf
                                            *(int32_t *)(v1 + 12) = v14;
                                            *v22 = (int32_t)"\\\\.\\%s";
                                            *v23 = 127;
                                            *v24 = (int32_t)&g24;
                                            *v25 = 0x401be7;
                                            _snprintf(hKey, 0, NULL);
                                            v32 = v1;
                                            // branch -> 0x401bea
                                        }
                                        int32_t * v33 = (int32_t *)v32; // 0x401bed_0
                                        *v33 = v31;
                                        int32_t * v34 = (int32_t *)(v32 - 4); // 0x401bf0_1
                                        *v34 = 0x401bf5;
                                        RegCloseKey(hKey);
                                        *v33 = (int32_t)&g21;
                                        g1 = (int32_t)hKey;
                                        *v34 = 0x401c05;
                                        ((int32_t (*)())hKey)();
                                        if (g1 == 0) {
                                            v16 = v1 + 16;
                                            result = &g24;
                                            // 0x401c38
                                            *(int32_t *)(v16 - 16) = v8;
                                            *(int32_t *)(v16 - 20) = 0x401c45;
                                            SetupDiDestroyDeviceInfoList(hKey);
                                            v2 = result;
                                            // branch -> 0x401c70
                                            // 0x401c70
                                            return result;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // 0x401c15
                    if (!SetupDiEnumDeviceInfo(v7, v17, (struct _SP_DEVINFO_DATA *)&v9)) {
                        v16 = v3;
                        result = 0;
                        // break -> 0x401c38
                        break;
                    }
                    v17++;
                    // continue -> 0x401ab2
                }
                // 0x401c38
                *(int32_t *)(v16 - 16) = v8;
                *(int32_t *)(v16 - 20) = 0x401c45;
                SetupDiDestroyDeviceInfoList(hKey);
                v2 = result;
                // branch -> 0x401c70
                // 0x401c70
                return result;
            }
            // 0x401c38
            *(int32_t *)(v16 - 16) = v8;
            *(int32_t *)(v16 - 20) = 0x401c45;
            SetupDiDestroyDeviceInfoList(hKey);
            v2 = result;
            result2 = result;
            // branch -> 0x401c70
        }
        // 0x401c70
        return result2;
    }
    // 0x401a6e
    v2 = 0;
    // branch -> 0x401c70
    // 0x401c70
    return 0;
}

// Address range: 0x401e00 - 0x4027cf
int32_t _getopt_parse(int32_t a1, int32_t a2, char * a3, char * a4, int32_t * a5, int32_t * a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = (int32_t)a5;
    int32_t v3 = (int32_t)a6;
    int32_t v4 = g5; // 0x401e03
    int32_t v5 = g7; // 0x401e04
    int32_t v6 = g3; // 0x401e05
    int32_t v7 = g12; // 0x401e09
    g4 = v7;
    int32_t v8 = g26; // 0x401e0f
    int32_t v9 = (int32_t)(v7 < 1) | v8; // 0x401e1f
    g26 = v9;
    int32_t v10; // 0x401e76
    int32_t v11; // 0x40234d179
    int32_t v12;
    int32_t v13;
    int32_t v14;
    int32_t v15;
    int32_t v16; // 0x401e70
    int32_t v17;
    int32_t v18; // 0x401e4f
    if (v9 == 0) {
        int32_t v19 = g29; // 0x401e2e
        int32_t v20 = v19; // edi
        if (v7 >= v19) {
            char * v21 = g28;
            if (v21 != NULL) {
                unsigned char v22 = *v21; // 0x402073
                int32_t v23 = (int32_t)v22 | v6 & -256; // 0x402073
                if (v23 != 0) {
                    int32_t v24 = (int32_t)v21 + 1; // 0x40207d
                    int32_t v25 = (int32_t)a4;
                    g4 = v25;
                    int32_t result = v22; // 0x402081
                    g14 = (char *)result;
                    char * v26 = (char *)v24;
                    g28 = v26;
                    int32_t v27 = v8 & -256; // 0x40208f
                    int32_t v28 = (int32_t)*a4 | v27; // 0x40208f
                    int32_t v29 = v25; // 0x40247b
                    int32_t v30 = v28; // 0x40247c
                    switch (v28) {
                        case 43: {
                            int32_t v31 = v25 + 1; // 0x402300
                            g4 = v31;
                            // branch -> 0x4020a3
                            v29 = v31;
                            v30 = (int32_t)*(char *)v31 | v27;
                        }
                        default: {
                            int32_t v32 = v29; // 0x40249a
                            int32_t v33 = v30; // 0x4020b5
                            if (v30 % 256 == 58) {
                                int32_t v34 = v29 + 1; // 0x40247b
                                g4 = v34;
                                v32 = v34;
                                v33 = (int32_t)*(char *)v34 | v30 & -256;
                                // branch -> 0x4020ac
                            }
                            char * v35;
                            int32_t v36; // 0x4022c3
                            int32_t v37; // 0x402320
                            int32_t v38; // 0x40261b
                            while (true) {
                                // 0x4020ac
                                if (v23 == v33) {
                                    // 0x402441
                                    if (v32 != 0) {
                                        // 0x402449
                                        if (*(char *)(v32 + 1) != 58) {
                                            // 0x40244f
                                            g25 = 0;
                                            if (v24 != 0) {
                                                // 0x402461
                                                if (*v26 != 0) {
                                                    // 0x402466
                                                    // branch -> 0x40246b
                                                    // 0x40246b
                                                    g12 = g30;
                                                    // branch -> 0x40200c
                                                    // 0x40200c
                                                    g3 = v6;
                                                    g7 = v5;
                                                    g5 = v4;
                                                    return result;
                                                }
                                            }
                                            // 0x4024e1
                                            // branch -> 0x40246b
                                            // 0x40246b
                                            g12 = g30 + 1;
                                            // branch -> 0x40200c
                                            // 0x40200c
                                            g3 = v6;
                                            g7 = v5;
                                            g5 = v4;
                                            return result;
                                        }
                                        // 0x402490
                                        g25 = v24;
                                        if (*v26 == 0) {
                                            // 0x40249a
                                            if (*(char *)(v32 + 2) == 58) {
                                                // 0x40271d
                                                g25 = 0;
                                                // branch -> 0x4024cc
                                                // 0x4024cc
                                                g28 = NULL;
                                                g12 = g30 + 1;
                                                // branch -> 0x4024e1
                                                // 0x4024e1
                                                // branch -> 0x40246b
                                                // 0x40246b
                                                g12 = g30 + 1;
                                                // branch -> 0x40200c
                                                // 0x40200c
                                                g3 = v6;
                                                g7 = v5;
                                                g5 = v4;
                                                return result;
                                            }
                                            // 0x4024a4
                                            if (a2 - g30 >= 2) {
                                                int32_t v39 = g30 + 1; // 0x4024bb
                                                g30 = v39;
                                                g25 = *(int32_t *)(4 * v39 + (int32_t)a3);
                                                // branch -> 0x4024cc
                                                // 0x4024cc
                                                g28 = NULL;
                                                g12 = g30 + 1;
                                                // branch -> 0x4024e1
                                                // 0x4024e1
                                                // branch -> 0x40246b
                                                // 0x40246b
                                                g12 = g30 + 1;
                                                // branch -> 0x40200c
                                                // 0x40200c
                                                g3 = v6;
                                                g7 = v5;
                                                g5 = v4;
                                                return result;
                                            }
                                            int32_t chars_printed = g30; // 0x402700
                                            if (g13 != 0) {
                                                int32_t v40 = *(int32_t *)a3; // 0x4026ec
                                                g4 = v40;
                                                chars_printed = fprintf((struct _IO_FILE *)(g36 + 64), "%s: option requires an argument -- %c\n", (char *)v40, v22);
                                                // branch -> 0x4026fd
                                            }
                                            int32_t v41 = chars_printed & -256; // 0x402700
                                            int32_t v42 = (int32_t)*a4 | v41; // 0x402700
                                            int32_t v43 = v42; // 0x40270c
                                            uint32_t v44; // 0x40270c
                                            switch (v42) {
                                                case 43: {
                                                    // 0x40272c
                                                    // branch -> 0x40270a
                                                    v43 = (int32_t)*(char *)(v25 + 1) | v41;
                                                }
                                                default: {
                                                    // 0x40270a
                                                    v44 = ((int32_t)(v43 % 256 == 58) | v43 & -256) ^ 1;
                                                    // branch -> 0x40200c
                                                    // 0x40200c
                                                    g3 = v6;
                                                    g7 = v5;
                                                    g5 = v4;
                                                    return v44 % 2 | -v44 & 4 | 58;
                                                }
                                                case 45: {
                                                    // 0x40272c
                                                    v43 = (int32_t)*(char *)(v25 + 1) | v41;
                                                    // branch -> 0x40270a
                                                    // 0x40270a
                                                    v44 = ((int32_t)(v43 % 256 == 58) | v43 & -256) ^ 1;
                                                    // branch -> 0x40200c
                                                    // 0x40200c
                                                    g3 = v6;
                                                    g7 = v5;
                                                    g5 = v4;
                                                    return v44 % 2 | -v44 & 4 | 58;
                                                }
                                            }
                                        }
                                        // 0x4024cc
                                        g28 = NULL;
                                        g12 = g30 + 1;
                                        // branch -> 0x4024e1
                                        // 0x4024e1
                                        // branch -> 0x40246b
                                        // 0x40246b
                                        g12 = g30 + 1;
                                        // branch -> 0x40200c
                                        // 0x40200c
                                        g3 = v6;
                                        g7 = v5;
                                        g5 = v4;
                                        return result;
                                    }
                                } else {
                                    int32_t v45 = v32 + 1; // 0x4020b4
                                    g4 = v45;
                                    int32_t v46 = (int32_t)*(char *)v45 | v33 & -256; // 0x4020b5
                                    if (v46 == 0) {
                                        // break -> 0x4020bb
                                        break;
                                    }
                                    v32 = v45;
                                    v33 = v46;
                                    // continue -> 0x4020ac
                                    continue;
                                }
                                // 0x4020bb
                                v36 = g13;
                                if (a1 == 2) {
                                    // 0x4022c3
                                    if (v36 != 0) {
                                        // 0x402611
                                        g28 = v21;
                                        v38 = *(int32_t *)a3;
                                        fprintf((struct _IO_FILE *)(g36 + 64), "%s: unrecognised option `-%s'\n", (char *)v38, v21);
                                        // branch -> 0x4022d1
                                    }
                                    // 0x4022d1
                                    g28 = NULL;
                                    g14 = NULL;
                                    // branch -> 0x4022e5
                                    // 0x4022e5
                                    // branch -> 0x4022eb
                                    // 0x4022eb
                                    g12 = g30 + 1;
                                    // branch -> 0x40200c
                                    // 0x40200c
                                    g3 = v6;
                                    g7 = v5;
                                    g5 = v4;
                                    return 63;
                                }
                                // 0x4020c5
                                v35 = v26;
                                if (v36 != 0) {
                                    // 0x402314
                                    v37 = *(int32_t *)a3;
                                    fprintf((struct _IO_FILE *)(g36 + 64), "%s: invalid option -- %c\n", (char *)v37, v22);
                                    v35 = g28;
                                    // branch -> 0x4020d3
                                }
                                // 0x4020d3
                                if (v35 != NULL) {
                                    // 0x4020e0
                                    if (*v35 != 0) {
                                        // 0x4020e9
                                        // branch -> 0x4022eb
                                        // 0x4022eb
                                        g12 = g30;
                                        // branch -> 0x40200c
                                        // 0x40200c
                                        g3 = v6;
                                        g7 = v5;
                                        g5 = v4;
                                        return 63;
                                    }
                                }
                                // 0x4022e5
                                // branch -> 0x4022eb
                                // 0x4022eb
                                g12 = g30 + 1;
                                // branch -> 0x40200c
                                // 0x40200c
                                g3 = v6;
                                g7 = v5;
                                g5 = v4;
                                return 63;
                            }
                            // 0x4020bb
                            v36 = g13;
                            if (a1 == 2) {
                                // 0x4022c3
                                if (v36 != 0) {
                                    // 0x402611
                                    g28 = v21;
                                    v38 = *(int32_t *)a3;
                                    fprintf((struct _IO_FILE *)(g36 + 64), "%s: unrecognised option `-%s'\n", (char *)v38, v21);
                                    // branch -> 0x4022d1
                                }
                                // 0x4022d1
                                g28 = NULL;
                                g14 = NULL;
                                // branch -> 0x4022e5
                            } else {
                                // 0x4020c5
                                v35 = v26;
                                if (v36 != 0) {
                                    // 0x402314
                                    v37 = *(int32_t *)a3;
                                    fprintf((struct _IO_FILE *)(g36 + 64), "%s: invalid option -- %c\n", (char *)v37, v22);
                                    v35 = g28;
                                    // branch -> 0x4020d3
                                }
                                // 0x4020d3
                                if (v35 != NULL) {
                                    // 0x4020e0
                                    if (*v35 != 0) {
                                        // 0x4020e9
                                        // branch -> 0x4022eb
                                        // 0x4022eb
                                        g12 = g30;
                                        // branch -> 0x40200c
                                        // 0x40200c
                                        g3 = v6;
                                        g7 = v5;
                                        g5 = v4;
                                        return 63;
                                    }
                                }
                            }
                            // 0x4022e5
                            // branch -> 0x4022eb
                            // 0x4022eb
                            g12 = g30 + 1;
                            // branch -> 0x40200c
                            // 0x40200c
                            g3 = v6;
                            g7 = v5;
                            g5 = v4;
                            return 63;
                        }
                        case 45: {
                            // 0x4022fa
                            g4 = v25 + 1;
                            // branch -> 0x4020a3
                            break;
                        }
                    }
                }
            }
            int32_t v47 = g27; // 0x4021fd
            int32_t v48 = g30; // 0x402209
            int32_t v49;
            if (v19 < v47) {
                int32_t v50 = 1 - v47 + v48; // esi
                int32_t v51;
                _alloca(v51);
                int32_t v52;
                int32_t v53 = &v52; // 0x40222e_2
                int32_t v54 = v50; // 0x402231
                v52 = v53;
                int32_t v55 = g27; // 0x402483
                int32_t v56; // 0x4022ab
                int32_t v57;
                int32_t v58; // 0x40228c
                int32_t v59; // 0x402296
                int32_t v60; // 0x4022ae
                int32_t v61; // 0x40226a
                int32_t v62; // 0x40228c
                int32_t v63; // 0x4022b2
                int32_t v64; // 0x402263
                int32_t v65; // 0x402274
                int32_t v66; // 0x40227a
                int32_t v67; // 0x40229d
                int32_t v68; // 0x40229d
                int32_t v69; // 0x4022a5
                int32_t v70; // 0x4022b2
                int32_t v71; // 0x402286
                int32_t v72; // 0x402289
                if (v54 < 1) {
                    // branch -> 0x402260
                } else {
                    // 0x40223c
                    int32_t v73;
                    int32_t v74 = &v73; // 0x402248_2
                    int32_t v75 = 4 * v55 + (int32_t)a3; // 0x40224a
                    *(int32_t *)(v53 + 4 * v74) = *(int32_t *)v75;
                    int32_t v76 = v74 + 1; // 0x40225b515
                    if (v76 != v50) {
                        int32_t v77 = v75 + 4;
                        *(int32_t *)(v52 + 4 * v76) = *(int32_t *)v77;
                        int32_t v78 = v76 + 1; // 0x40225b
                        v54 = v78;
                        while (v78 != v50) {
                            // 0x402250
                            v77 += 4;
                            *(int32_t *)(v52 + 4 * v78) = *(int32_t *)v77;
                            v78++;
                            v54 = v78;
                            // continue -> 0x402250
                        }
                        // 0x402260
                        v64 = v55 - 1;
                        g4 = v64;
                        g27 = v64;
                        v61 = v20;
                        v68 = v61;
                        v59 = v54;
                        if (v64 >= v61) {
                            // 0x40226e
                            v57 = (int32_t)a3;
                            v65 = 4 * v55 + v57;
                            v66 = 4 * (v54 + v64) + v57;
                            g4 = v64 - 1;
                            *(int32_t *)v66 = *(int32_t *)(v65 - 4);
                            v71 = v65 - 4;
                            v72 = v66 - 4;
                            v58 = g4;
                            v62 = v20;
                            // branch -> 0x402280
                            while (v58 >= v62) {
                                // 0x402280
                                g4 = v58 - 1;
                                *(int32_t *)v72 = *(int32_t *)(v71 - 4);
                                v71 -= 4;
                                v72 -= 4;
                                v58 = g4;
                                v62 = v20;
                                // continue -> 0x402280
                            }
                            // 0x402290
                            g27 = v58;
                            v68 = v62;
                            v59 = v50;
                            // branch -> 0x402296
                        }
                        // 0x402296
                        v70 = v68;
                        v63 = v59;
                        if (v59 >= 1) {
                            // 0x40229a
                            v67 = 4 * v68 + (int32_t)a3;
                            v69 = 0;
                            g4 = v69 + 1;
                            *(int32_t *)v67 = *(int32_t *)(4 * v69 + v52);
                            v56 = v67 + 4;
                            v60 = g4;
                            // branch -> 0x4022a2
                            while (v60 != v50) {
                                // 0x4022a2
                                v69 = v60;
                                g4 = v69 + 1;
                                *(int32_t *)v56 = *(int32_t *)(4 * v69 + v52);
                                v56 += 4;
                                v60 = g4;
                                // continue -> 0x4022a2
                            }
                            // 0x4022b2
                            v70 = v20;
                            v63 = v60;
                            // branch -> 0x4022b2
                        }
                        // 0x4022b2
                        v17 = v55;
                        // branch -> 0x401e70
                        // 0x401e70
                        g29 = v63 + v70;
                        v14 = (int32_t)a3;
                        v15 = (int32_t)a4;
                        v11 = v12;
                        // branch -> 0x401e70
                        while (true) {
                            // 0x401e70
                            v16 = g30;
                            v10 = v16 + 1;
                            g30 = v10;
                            if (v10 < a2) {
                              lab_0x401e86_3:
                                // 0x401e86
                                g27 = v10;
                                int32_t v79 = 4 * v10; // 0x401e8f
                                int32_t * v80 = (int32_t *)(v79 + v14); // 0x401e8f_0
                                int32_t v81 = *v80; // 0x401e8f
                                g4 = v81;
                                char * v82 = (char *)v81;
                                g28 = v82;
                                int32_t v83; // 0x40234d176
                                unsigned char v84; // 0x401fa3
                                int32_t v85; // 0x401fa3
                                if (*v82 == 45) {
                                    int32_t v86 = v81 + 1; // 0x401ea1
                                    char * v87 = (char *)v86;
                                    g28 = v87;
                                    int32_t v88; // 0x40234d177
                                    char v89;
                                    int32_t v90; // 0x401fa3278
                                    unsigned char v91; // 0x401ea9
                                    int32_t v92; // 0x402349
                                    int32_t v93; // 0x401ebc
                                    switch ((int32_t)v91 || v86 & -256) {
                                        default: {
                                            // 0x401ebc
                                            v93 = v1;
                                            if (v93 < 2) {
                                                // 0x402336
                                                // branch -> 0x40233d
                                                // 0x40233d
                                                g5 = v15;
                                                g7 = v14;
                                                g3 = a2;
                                                int32_t result2 = _getopt_parse(0, a2, a3, a4, (int32_t *)v51, (int32_t *)v17, v11); // 0x40234d
                                                // branch -> 0x40200c
                                                // 0x40200c
                                                g3 = v6;
                                                g7 = v5;
                                                g5 = v4;
                                                return result2;
                                            }
                                            v90 = v10;
                                          lab_0x401ec6:
                                            // 0x401ec6
                                            g4 = v2;
                                            g25 = 0;
                                            int32_t v94 = v90; // 0x401fa3277
                                            int32_t v95 = v11; // 0x40234d178
                                            char * format;
                                            if (a5 != NULL) {
                                                int32_t v96 = *a5; // 0x401eea
                                                if (v96 != 0) {
                                                    int32_t v97 = (int32_t)v87;
                                                    int32_t v98 = v97 + 1; // 0x401f02
                                                    int32_t v99 = v97 + 2; // 0x401f05
                                                    int32_t v100 = 0; // 0x40237b260
                                                    int32_t v101 = v2; // 0x4021e1
                                                    int32_t v102 = v2 + 16; // 0x401f6c255
                                                    int32_t v103 = v99; // 0x401f1c
                                                    int32_t v104 = -1; // 0x40268a181
                                                    int32_t v105 = 0; // 0x402107180
                                                    // branch -> 0x401f1c
                                                    int32_t v106;
                                                    int32_t v107; // 0x40237b261
                                                    int32_t v108; // 0x401fa3280
                                                    int32_t v109; // 0x40268a182
                                                    while (true) {
                                                        int32_t v110 = (int32_t)*v87 | v103 & -256; // 0x401f1c
                                                        v108 = 0;
                                                        int32_t v111 = v100; // 0x40237b262
                                                        int32_t v112 = v96; // 0x401f41
                                                        int32_t v113; // 0x402118
                                                        int32_t stream3; // 0x402167
                                                        int32_t stream; // 0x402590
                                                        int32_t v114; // 0x40210c
                                                        int32_t v115; // 0x402112
                                                        int32_t v116; // 0x402179
                                                        int32_t v117; // 0x4025a2
                                                        int32_t v118; // 0x4021d6
                                                        if (v110 != 0) {
                                                            // 0x401f22
                                                            g4 = v98;
                                                            int32_t v119; // 0x401f41253
                                                            int32_t v120; // 0x4021f2
                                                            int32_t v121; // 0x402556
                                                            int32_t v122; // 0x401f60
                                                            uint32_t v123; // 0x402556
                                                            int32_t v124; // 0x402547
                                                            int32_t v125; // 0x402547
                                                            if ((int32_t)*(char *)v96 != v110) {
                                                                v119 = v96;
                                                                v120 = v98;
                                                                v122 = v110;
                                                              lab_0x401f60:
                                                                // 0x401f60
                                                                if (v122 % 256 == 61) {
                                                                    goto lab_0x4021f2;
                                                                }
                                                                v108 = v122;
                                                                v107 = v100;
                                                                v109 = v104;
                                                                goto lab_0x401f69;
                                                                char v129 = *(char *)v112; // 0x401f41
                                                                if (v129 != 0) {
                                                                    goto lab_0x401f4a_2;
                                                                }
                                                                int32_t v130 = v3; // eax
                                                                g28 = NULL;
                                                                v115 = v111;
                                                                v114 = v10;
                                                                if (a6 != NULL) {
                                                                    // 0x402104
                                                                    g4 = v3;
                                                                    *a6 = v105;
                                                                    int32_t v131 = g30;
                                                                    int32_t v132 = g25;
                                                                    v115 = v132;
                                                                    v114 = v131;
                                                                    // branch -> 0x40210c
                                                                }
                                                                // 0x40210c
                                                                v113 = v114 + 1;
                                                                g12 = v113;
                                                                int32_t v133; // ebx
                                                                int32_t result3; // 0x40200f
                                                                int32_t v134; // 0x4021e1
                                                                int32_t v135; // 0x40230c
                                                                if (v115 == 0) {
                                                                    int32_t v136 = *(int32_t *)(v101 + 4); // 0x4021ab
                                                                    if (v136 == 1) {
                                                                        // 0x4021b1
                                                                        if (v113 < a2) {
                                                                            // 0x4021ba
                                                                            g30 = v113;
                                                                            int32_t v137 = *(int32_t *)(4 * v113 + v14); // 0x4021c3
                                                                            g25 = v137;
                                                                            g12 = v114 + 2;
                                                                            // branch -> 0x4021d3
                                                                            // 0x4021d3
                                                                            g4 = v101;
                                                                            v118 = *(int32_t *)(v101 + 8);
                                                                            if (v118 != 0) {
                                                                                // 0x4021e1
                                                                                v134 = *(int32_t *)(v101 + 12);
                                                                                *(int32_t *)v118 = v134;
                                                                                g3 = v6;
                                                                                g7 = v5;
                                                                                g5 = v4;
                                                                                return 0;
                                                                            }
                                                                            // 0x402309
                                                                            v135 = *(int32_t *)(v101 + 12);
                                                                            v50 = v135;
                                                                            // branch -> 0x40200c
                                                                            // 0x40200c
                                                                            result3 = v50;
                                                                            g3 = v6;
                                                                            g7 = v5;
                                                                            g5 = v4;
                                                                            return result3;
                                                                        }
                                                                        unsigned char v138 = *a4; // 0x402547
                                                                        int32_t v139 = v130; // 0x402547
                                                                        v124 = v139 & -256;
                                                                        v125 = v124 | (int32_t)v138;
                                                                        v121 = v125;
                                                                        unsigned char v140; // 0x4025ca
                                                                        int32_t v141; // 0x4025ca
                                                                        switch (v125) {
                                                                            case 43: {
                                                                                // 0x4025c7
                                                                                g4 = v15;
                                                                                v140 = *(char *)(v15 + 1);
                                                                                v141 = (int32_t)v140 | v124;
                                                                                // branch -> 0x402551
                                                                                v121 = v141;
                                                                            }
                                                                            default: {
                                                                                // 0x402551
                                                                                v123 = ((int32_t)(v121 % 256 == 58) | v121 & -256) ^ 1;
                                                                                int32_t v142 = *(int32_t *)a3; // 0x40255e
                                                                                v50 = v123 % 2 | -v123 & 4 | 58;
                                                                                int32_t v143 = g13; // 0x402564
                                                                                if (v143 != 0) {
                                                                                    // 0x40256d
                                                                                    v106 = 0x2d2d;
                                                                                    int32_t v144 = g36; // 0x402589
                                                                                    stream = v144 + 64;
                                                                                    v133 = stream;
                                                                                    fprintf((struct _IO_FILE *)stream, "%s: ", (char *)v142);
                                                                                    v117 = *(int32_t *)v101;
                                                                                    int32_t stream2 = v133; // 0x4025ae
                                                                                    fprintf((struct _IO_FILE *)stream2, "option `%s%s' requires an argument\n", &v106, (char *)v117);
                                                                                    // branch -> 0x4025b7
                                                                                }
                                                                                int32_t v145 = *(int32_t *)(v101 + 12); // 0x4025ba
                                                                                g14 = (char *)v145;
                                                                                // branch -> 0x40200c
                                                                                // 0x40200c
                                                                                result3 = v50;
                                                                                g3 = v6;
                                                                                g7 = v5;
                                                                                g5 = v4;
                                                                                return result3;
                                                                            }
                                                                            case 45: {
                                                                                // 0x4025c7
                                                                                g4 = v15;
                                                                                v140 = *(char *)(v15 + 1);
                                                                                v141 = (int32_t)v140 | v124;
                                                                                v121 = v141;
                                                                                // branch -> 0x402551
                                                                                break;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    int32_t v146 = *(int32_t *)(v101 + 4); // 0x40212a
                                                                    if (v146 == 0) {
                                                                        int32_t v147 = g13; // 0x402138
                                                                        int32_t v148 = *(int32_t *)a3; // 0x402140
                                                                        if (v147 != 0) {
                                                                            // 0x402144
                                                                            v106 = 0x2d2d;
                                                                            int32_t v149 = g36; // 0x402160
                                                                            stream3 = v149 + 64;
                                                                            v133 = stream3;
                                                                            fprintf((struct _IO_FILE *)stream3, "%s: ", (char *)v148);
                                                                            v116 = *(int32_t *)v101;
                                                                            int32_t stream4 = v133; // 0x402185
                                                                            fprintf((struct _IO_FILE *)stream4, "option `%s%s' doesn't accept an argument\n", &v106, (char *)v116);
                                                                            // branch -> 0x40218e
                                                                        }
                                                                        // 0x40218e
                                                                        g4 = v101;
                                                                        int32_t v150 = *(int32_t *)(v101 + 12); // 0x402196
                                                                        g14 = (char *)v150;
                                                                        g3 = v6;
                                                                        g7 = v5;
                                                                        g5 = v4;
                                                                        return 63;
                                                                    }
                                                                }
                                                                // 0x4021d3
                                                                g4 = v101;
                                                                v118 = *(int32_t *)(v101 + 8);
                                                                if (v118 != 0) {
                                                                    // 0x4021e1
                                                                    v134 = *(int32_t *)(v101 + 12);
                                                                    *(int32_t *)v118 = v134;
                                                                    g3 = v6;
                                                                    g7 = v5;
                                                                    g5 = v4;
                                                                    return 0;
                                                                }
                                                                // 0x402309
                                                                v135 = *(int32_t *)(v101 + 12);
                                                                v50 = v135;
                                                                // branch -> 0x40200c
                                                                // 0x40200c
                                                                result3 = v50;
                                                                g3 = v6;
                                                                g7 = v5;
                                                                g5 = v4;
                                                                return result3;
                                                            }
                                                            int32_t v151 = v96; // 0x401f3c
                                                            int32_t v152 = v110; // 0x401f39
                                                            int32_t v153 = v99; // 0x401f34
                                                            // branch -> 0x401f39
                                                            while (true) {
                                                                int32_t v154 = (int32_t)*(char *)(v153 - 1) | v152 & -256; // 0x401f39
                                                                int32_t v155 = v151 + 1; // 0x401f3c
                                                                if (v154 != 0) {
                                                                    // 0x401f30
                                                                    g4 = v153;
                                                                    int32_t v156 = v153 + 1; // 0x401f34
                                                                    if ((int32_t)*(char *)v155 != v154) {
                                                                        v119 = v155;
                                                                        v120 = v153;
                                                                        v122 = v154;
                                                                        // break (via goto) -> 0x401f60
                                                                        goto lab_0x401f60;
                                                                    }
                                                                    v151 = v155;
                                                                    v152 = v154;
                                                                    v153 = v156;
                                                                    // continue -> 0x401f39
                                                                    continue;
                                                                }
                                                            }
                                                            // 0x401f60
                                                            int32_t v126; // 0x401f6f
                                                            int32_t v128; // 0x401f75
                                                            int32_t v127; // 0x401f73
                                                            if (v122 % 256 != 61) {
                                                                v108 = v122;
                                                                v107 = v100;
                                                                v109 = v104;
                                                              lab_0x401f69:
                                                                // 0x401f69
                                                                v126 = v105 + 1;
                                                                v127 = *(int32_t *)v102;
                                                                v128 = v102 + 16;
                                                                if (v127 == 0) {
                                                                    // break -> 0x401f7c
                                                                    break;
                                                                }
                                                                v100 = v107;
                                                                v101 = v102;
                                                                v102 = v128;
                                                                v96 = v127;
                                                                v103 = v108;
                                                                v104 = v109;
                                                                v105 = v126;
                                                                // continue -> 0x401f1c
                                                                continue;
                                                            }
                                                          lab_0x4021f2:
                                                            // 0x4021f2
                                                            g25 = v120;
                                                            v108 = v122;
                                                            v111 = v120;
                                                            // branch -> 0x401f41
                                                            // 0x401f41
                                                            if (*(char *)v119 != 0) {
                                                              lab_0x401f4a_2:
                                                                // 0x401f4a
                                                                if (v104 > 0) {
                                                                    // 0x4024e9
                                                                    g14 = NULL;
                                                                    g28 = NULL;
                                                                    g12 = v16 + 2;
                                                                    if (g13 != 0) {
                                                                        // 0x402515
                                                                        format = "%s: option `%s' is ambiguous\n";
                                                                        // branch -> 0x402529
                                                                        // 0x402529
                                                                        fprintf((struct _IO_FILE *)(g36 + 64), format);
                                                                        // branch -> 0x40200c
                                                                        // 0x40200c
                                                                        g3 = v6;
                                                                        g7 = v5;
                                                                        g5 = v4;
                                                                        return 63;
                                                                    }
                                                                } else {
                                                                    v107 = v111;
                                                                    v109 = v105;
                                                                    // branch -> 0x401f69
                                                                    // 0x401f69
                                                                    v126 = v105 + 1;
                                                                    v127 = *(int32_t *)v102;
                                                                    v128 = v102 + 16;
                                                                    if (v127 == 0) {
                                                                        // break -> 0x401f7c
                                                                        break;
                                                                    }
                                                                    v100 = v107;
                                                                    v101 = v102;
                                                                    v102 = v128;
                                                                    v96 = v127;
                                                                    v103 = v108;
                                                                    v104 = v109;
                                                                    v105 = v126;
                                                                    // continue -> 0x401f1c
                                                                    continue;
                                                                }
                                                                // 0x402639
                                                                // branch -> 0x40200c
                                                                // 0x40200c
                                                                g3 = v6;
                                                                g7 = v5;
                                                                g5 = v4;
                                                                return 63;
                                                            }
                                                            // 0x4020f3
                                                            g28 = NULL;
                                                            v115 = v111;
                                                            v114 = v10;
                                                            if (a6 != NULL) {
                                                                // 0x402104
                                                                g4 = v3;
                                                                *a6 = v105;
                                                                v115 = g25;
                                                                v114 = g30;
                                                                // branch -> 0x40210c
                                                            }
                                                            // 0x40210c
                                                            v113 = v114 + 1;
                                                            g12 = v113;
                                                            if (v115 == 0) {
                                                                // 0x4021a8
                                                                if (*(int32_t *)(v101 + 4) == 1) {
                                                                    // 0x4021b1
                                                                    if (v113 < a2) {
                                                                        // 0x4021ba
                                                                        g30 = v113;
                                                                        g25 = *(int32_t *)(4 * v113 + v14);
                                                                        g12 = v114 + 2;
                                                                        // branch -> 0x4021d3
                                                                        // 0x4021d3
                                                                        g4 = v101;
                                                                        v118 = *(int32_t *)(v101 + 8);
                                                                        if (v118 == 0) {
                                                                            // 0x402309
                                                                            // branch -> 0x40200c
                                                                            // 0x40200c
                                                                            g3 = v6;
                                                                            g7 = v5;
                                                                            g5 = v4;
                                                                            return *(int32_t *)(v101 + 12);
                                                                        }
                                                                        // 0x4021e1
                                                                        *(int32_t *)v118 = *(int32_t *)(v101 + 12);
                                                                        g3 = v6;
                                                                        g7 = v5;
                                                                        g5 = v4;
                                                                        return 0;
                                                                    }
                                                                    // 0x402544
                                                                    v124 = v3 & -256;
                                                                    v125 = v124 | (int32_t)*a4;
                                                                    v121 = v125;
                                                                    switch (v125) {
                                                                        case 43: {
                                                                            // 0x4025c7
                                                                            g4 = v15;
                                                                            // branch -> 0x402551
                                                                            v121 = (int32_t)*(char *)(v15 + 1) | v124;
                                                                        }
                                                                        default: {
                                                                            // 0x402551
                                                                            v123 = ((int32_t)(v121 % 256 == 58) | v121 & -256) ^ 1;
                                                                            if (g13 != 0) {
                                                                                // 0x40256d
                                                                                v106 = 0x2d2d;
                                                                                stream = g36 + 64;
                                                                                fprintf((struct _IO_FILE *)stream, "%s: ", (char *)*(int32_t *)a3);
                                                                                v117 = *(int32_t *)v101;
                                                                                fprintf((struct _IO_FILE *)stream, "option `%s%s' requires an argument\n", &v106, (char *)v117);
                                                                                // branch -> 0x4025b7
                                                                            }
                                                                            // 0x4025b7
                                                                            g14 = (char *)*(int32_t *)(v101 + 12);
                                                                            // branch -> 0x40200c
                                                                            // 0x40200c
                                                                            g3 = v6;
                                                                            g7 = v5;
                                                                            g5 = v4;
                                                                            return v123 % 2 | -v123 & 4 | 58;
                                                                        }
                                                                        case 45: {
                                                                            // 0x4025c7
                                                                            g4 = v15;
                                                                            // branch -> 0x402551
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                // 0x402127
                                                                if (*(int32_t *)(v101 + 4) == 0) {
                                                                    // 0x402135
                                                                    if (g13 != 0) {
                                                                        // 0x402144
                                                                        v106 = 0x2d2d;
                                                                        stream3 = g36 + 64;
                                                                        fprintf((struct _IO_FILE *)stream3, "%s: ", (char *)*(int32_t *)a3);
                                                                        v116 = *(int32_t *)v101;
                                                                        fprintf((struct _IO_FILE *)stream3, "option `%s%s' doesn't accept an argument\n", &v106, (char *)v116);
                                                                        // branch -> 0x40218e
                                                                    }
                                                                    // 0x40218e
                                                                    g4 = v101;
                                                                    g14 = (char *)*(int32_t *)(v101 + 12);
                                                                    g3 = v6;
                                                                    g7 = v5;
                                                                    g5 = v4;
                                                                    return 63;
                                                                }
                                                            }
                                                            // 0x4021d3
                                                            g4 = v101;
                                                            v118 = *(int32_t *)(v101 + 8);
                                                            if (v118 == 0) {
                                                                // 0x402309
                                                                // branch -> 0x40200c
                                                                // 0x40200c
                                                                g3 = v6;
                                                                g7 = v5;
                                                                g5 = v4;
                                                                return *(int32_t *)(v101 + 12);
                                                            }
                                                            // 0x4021e1
                                                            *(int32_t *)v118 = *(int32_t *)(v101 + 12);
                                                            g3 = v6;
                                                            g7 = v5;
                                                            g5 = v4;
                                                            return 0;
                                                        }
                                                        // 0x401f41
                                                        if (*(char *)v112 != 0) {
                                                            goto lab_0x401f4a_2;
                                                        }
                                                        // 0x4020f3
                                                        g28 = NULL;
                                                        v115 = v111;
                                                        v114 = v10;
                                                        if (a6 != NULL) {
                                                            // 0x402104
                                                            g4 = v3;
                                                            *a6 = v105;
                                                            v115 = g25;
                                                            v114 = g30;
                                                            // branch -> 0x40210c
                                                        }
                                                        // 0x40210c
                                                        v113 = v114 + 1;
                                                        g12 = v113;
                                                        if (v115 == 0) {
                                                            // 0x4021a8
                                                            if (*(int32_t *)(v101 + 4) == 1) {
                                                                // 0x4021b1
                                                                if (v113 < a2) {
                                                                    // 0x4021ba
                                                                    g30 = v113;
                                                                    g25 = *(int32_t *)(4 * v113 + v14);
                                                                    g12 = v114 + 2;
                                                                    // branch -> 0x4021d3
                                                                    // 0x4021d3
                                                                    g4 = v101;
                                                                    v118 = *(int32_t *)(v101 + 8);
                                                                    if (v118 == 0) {
                                                                        // 0x402309
                                                                        // branch -> 0x40200c
                                                                        // 0x40200c
                                                                        g3 = v6;
                                                                        g7 = v5;
                                                                        g5 = v4;
                                                                        return *(int32_t *)(v101 + 12);
                                                                    }
                                                                    // 0x4021e1
                                                                    *(int32_t *)v118 = *(int32_t *)(v101 + 12);
                                                                    g3 = v6;
                                                                    g7 = v5;
                                                                    g5 = v4;
                                                                    return 0;
                                                                }
                                                                // 0x402544
                                                                switch (v3 & -256 | (int32_t)*a4) {
                                                                    case 43: {
                                                                        // 0x4025c7
                                                                        g4 = v15;
                                                                        // branch -> 0x402551
                                                                    }
                                                                    default: {
                                                                        // 0x402551
                                                                        if (g13 != 0) {
                                                                            // 0x40256d
                                                                            v106 = 0x2d2d;
                                                                            stream = g36 + 64;
                                                                            fprintf((struct _IO_FILE *)stream, "%s: ", (char *)*(int32_t *)a3);
                                                                            v117 = *(int32_t *)v101;
                                                                            fprintf((struct _IO_FILE *)stream, "option `%s%s' requires an argument\n", &v106, (char *)v117);
                                                                            // branch -> 0x4025b7
                                                                        }
                                                                        // 0x4025b7
                                                                        g14 = (char *)*(int32_t *)(v101 + 12);
                                                                        // branch -> 0x40200c
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        break;
                                                                    }
                                                                    case 45: {
                                                                        // 0x4025c7
                                                                        g4 = v15;
                                                                        // branch -> 0x402551
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // 0x402127
                                                            if (*(int32_t *)(v101 + 4) == 0) {
                                                                // 0x402135
                                                                if (g13 != 0) {
                                                                    // 0x402144
                                                                    v106 = 0x2d2d;
                                                                    stream3 = g36 + 64;
                                                                    fprintf((struct _IO_FILE *)stream3, "%s: ", (char *)*(int32_t *)a3);
                                                                    v116 = *(int32_t *)v101;
                                                                    fprintf((struct _IO_FILE *)stream3, "option `%s%s' doesn't accept an argument\n", &v106, (char *)v116);
                                                                    // branch -> 0x40218e
                                                                }
                                                                // 0x40218e
                                                                g4 = v101;
                                                                g14 = (char *)*(int32_t *)(v101 + 12);
                                                                g3 = v6;
                                                                g7 = v5;
                                                                g5 = v4;
                                                                return 63;
                                                            }
                                                        }
                                                        // 0x4021d3
                                                        g4 = v101;
                                                        v118 = *(int32_t *)(v101 + 8);
                                                        if (v118 != 0) {
                                                            // 0x4021e1
                                                            *(int32_t *)v118 = *(int32_t *)(v101 + 12);
                                                            g3 = v6;
                                                            g7 = v5;
                                                            g5 = v4;
                                                            return 0;
                                                        }
                                                        // 0x402309
                                                        // branch -> 0x40200c
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x401f7c
                                                    g4 = v109;
                                                    if (v109 > 0) {
                                                        // 0x40235c
                                                        g28 = NULL;
                                                        int32_t v157 = v107; // 0x40273f
                                                        int32_t v158 = v10; // 0x402375
                                                        if (a6 != NULL) {
                                                            // 0x40236d
                                                            g4 = v109;
                                                            *a6 = v109;
                                                            v157 = g25;
                                                            v158 = g30;
                                                            // branch -> 0x402375
                                                        }
                                                        int32_t v159 = v158 + 1; // 0x402380
                                                        g12 = v159;
                                                        int32_t v160 = 16 * v109; // 0x40268a
                                                        int32_t v161; // 0x402734
                                                        int32_t v162; // 0x4026bd
                                                        int32_t v163; // 0x402734
                                                        if (v157 == 0) {
                                                            // 0x402684
                                                            g4 = v160;
                                                            int32_t v164 = v160 + v2; // 0x402693
                                                            v20 = v164;
                                                            if (*(int32_t *)(v164 + 4) == 1) {
                                                                // 0x40269b
                                                                if (v159 < a2) {
                                                                    // 0x4026a4
                                                                    g4 = v14;
                                                                    g30 = v159;
                                                                    g25 = *(int32_t *)(4 * v159 + v14);
                                                                    g12 = v158 + 2;
                                                                    v161 = v164;
                                                                    // branch -> 0x4026bd
                                                                    // 0x4026bd
                                                                    v162 = *(int32_t *)(v161 + 8);
                                                                    v163 = *(int32_t *)(v161 + 12);
                                                                    if (v162 == 0) {
                                                                        // 0x402734
                                                                        // branch -> 0x40200c
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    } else {
                                                                        // 0x4026c4
                                                                        *(int32_t *)v162 = v163;
                                                                        // branch -> 0x40200c
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                } else {
                                                                    // 0x40273c
                                                                    switch (*a4) {
                                                                        case 43: {
                                                                            // 0x4027b9
                                                                            // branch -> 0x402749
                                                                        }
                                                                        default: {
                                                                            // 0x402749
                                                                            g4 = v14;
                                                                            int32_t v165; // 0x4027ac
                                                                            if (g13 != 0) {
                                                                                // 0x402765
                                                                                v106 = 0x2d2d;
                                                                                int32_t stream5 = g36 + 64; // 0x402788
                                                                                fprintf((struct _IO_FILE *)stream5, "%s: ", (char *)*(int32_t *)a3);
                                                                                int32_t v166 = *(int32_t *)v20; // 0x402797
                                                                                fprintf((struct _IO_FILE *)stream5, "option `%s%s' requires an argument\n", &v106, (char *)v166);
                                                                                v165 = v20;
                                                                                // branch -> 0x4027ac
                                                                            } else {
                                                                                v165 = v164;
                                                                            }
                                                                            // 0x4027ac
                                                                            g14 = (char *)*(int32_t *)(v165 + 12);
                                                                            // branch -> 0x40200c
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                            break;
                                                                        }
                                                                        case 45: {
                                                                            // 0x4027b9
                                                                            // branch -> 0x402749
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                v161 = v164;
                                                            }
                                                        } else {
                                                            int32_t v167 = v160 + v2; // 0x40239e
                                                            v20 = v167;
                                                            if (*(int32_t *)(v167 + 4) == 0) {
                                                                // 0x4023ab
                                                                int32_t v168; // 0x402400
                                                                if (g13 != 0) {
                                                                    // 0x4023b9
                                                                    v106 = 0x2d2d;
                                                                    int32_t stream6 = g36 + 64; // 0x4023dc
                                                                    fprintf((struct _IO_FILE *)stream6, "%s: ", (char *)*(int32_t *)a3);
                                                                    int32_t v169 = *(int32_t *)v20; // 0x4023eb
                                                                    fprintf((struct _IO_FILE *)stream6, "option `%s%s' doesn't accept an argument\n", &v106, (char *)v169);
                                                                    v168 = v20;
                                                                    // branch -> 0x402400
                                                                } else {
                                                                    v168 = v167;
                                                                }
                                                                // 0x402400
                                                                g14 = (char *)*(int32_t *)(v168 + 12);
                                                                // branch -> 0x40200c
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            } else {
                                                                v161 = v167;
                                                            }
                                                        }
                                                        // 0x4026bd
                                                        v162 = *(int32_t *)(v161 + 8);
                                                        v163 = *(int32_t *)(v161 + 12);
                                                        if (v162 == 0) {
                                                            // 0x402734
                                                            // branch -> 0x40200c
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        } else {
                                                            // 0x4026c4
                                                            *(int32_t *)v162 = v163;
                                                            // branch -> 0x40200c
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    } else {
                                                        v94 = v108;
                                                        v95 = v99;
                                                    }
                                                } else {
                                                    v94 = v90;
                                                    v95 = v11;
                                                }
                                            }
                                            // 0x401f87
                                            if (v93 == 1) {
                                                // 0x402643
                                                g14 = NULL;
                                                g28 = NULL;
                                                g12 = v16 + 2;
                                                if (g13 == 0) {
                                                    // 0x402639
                                                    // branch -> 0x40200c
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    // 0x40266b
                                                    format = "%s: unrecognised option `%s'\n";
                                                    // branch -> 0x402529
                                                    // 0x402529
                                                    fprintf((struct _IO_FILE *)(g36 + 64), format);
                                                    // branch -> 0x40200c
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                // 0x401f91
                                                if (*v87 == 0) {
                                                    v83 = v95;
                                                    // 0x401fa0
                                                    v84 = *a4;
                                                    v85 = (int32_t)v84 | v94 & -256;
                                                    if (v85 == 45) {
                                                        // 0x402412
                                                        g28 = NULL;
                                                        g12 = v16 + 2;
                                                        g25 = *v80;
                                                        // branch -> 0x40200c
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    } else {
                                                      lab_0x401fae:
                                                        // 0x401fae
                                                        v89 = g31;
                                                        g4 = v89;
                                                        char v170;
                                                        char v171; // 0x40201b288
                                                        if (v89 == 0) {
                                                          lab_0x401fbb:
                                                            // 0x401fbb
                                                            if (((int32_t)v84 & -256) == 0x1000) {
                                                                // 0x401fc0
                                                                g31 = 0;
                                                                char v172;
                                                                if (v85 == 43) {
                                                                    v172 = 0;
                                                                  lab_0x401fe3:
                                                                    // 0x401fe3
                                                                    v170 = (int32_t)v172 | 16;
                                                                    g31 = v170;
                                                                    // branch -> 0x401ff2
                                                                } else {
                                                                    // 0x401fcf
                                                                    if (getenv("POSIXLY_CORRECT") == NULL) {
                                                                        // 0x401fcf
                                                                        // branch -> 0x401ff2
                                                                    } else {
                                                                        // 0x401fcf
                                                                        v172 = g31;
                                                                        // branch -> 0x401fe3
                                                                        goto lab_0x401fe3;
                                                                    }
                                                                    // 0x401ff2
                                                                    if (g31 != 16) {
                                                                        // break -> 0x401fff
                                                                        break;
                                                                    }
                                                                    v11 = v83;
                                                                    // continue -> 0x401e70
                                                                    continue;
                                                                }
                                                              lab_0x401ff2_3:
                                                                // 0x401ff2
                                                                if (v170 != 16) {
                                                                    // break -> 0x401fff
                                                                    break;
                                                                }
                                                                v11 = v83;
                                                                // continue -> 0x401e70
                                                                continue;
                                                            }
                                                        } else {
                                                          lab_0x402016:
                                                            // 0x402016
                                                            if (((int32_t)v84 & -256) == 0x1000) {
                                                                v170 = v89;
                                                                goto lab_0x401ff2_3;
                                                            }
                                                            // 0x40201b
                                                            v171 = v89 | v84;
                                                            g31 = v171;
                                                            v170 = v171;
                                                            // branch -> 0x401ff2
                                                            goto lab_0x401ff2_3;
                                                        }
                                                        // 0x40201b
                                                        v171 = v89 | v84;
                                                        g31 = v171;
                                                        v170 = v171;
                                                        // branch -> 0x401ff2
                                                        goto lab_0x401ff2_3;
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    v92 = v93;
                                                    v88 = v95;
                                                    // 0x40233d
                                                    g5 = v15;
                                                    g7 = v14;
                                                    g3 = a2;
                                                    _getopt_parse(v92, a2, a3, a4, (int32_t *)v51, (int32_t *)v17, v88);
                                                    _getopt_parse(v92, a2, a3, a4, (int32_t *)v51, (int32_t *)v17, v88);
                                                    // branch -> 0x40200c
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                            // 0x40233d
                                            g5 = v15;
                                            g7 = v14;
                                            g3 = a2;
                                            _getopt_parse(v92, a2, a3, a4, (int32_t *)v51, (int32_t *)v17, v88);
                                            _getopt_parse(v92, a2, a3, a4, (int32_t *)v51, (int32_t *)v17, v88);
                                            // branch -> 0x40200c
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                            break;
                                        }
                                        case 0: {
                                            v83 = v11;
                                            // 0x401fa0
                                            v84 = *a4;
                                            v85 = (int32_t)v84 | v10 & -256;
                                            if (v85 != 45) {
                                                goto lab_0x401fae;
                                            }
                                            // 0x402412
                                            g28 = NULL;
                                            g12 = v16 + 2;
                                            g25 = *v80;
                                            // branch -> 0x40200c
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                            break;
                                        }
                                        case 45: {
                                            char * v173 = (char *)(v81 + 2); // 0x402040_0
                                            if (*v173 == 0) {
                                                int32_t v174 = g29; // 0x4025cf
                                                v50 = v174;
                                                int32_t v175 = v174; // 0x4025fc
                                                int32_t v176; // 0x4025fc
                                                if (v10 > v174) {
                                                    int32_t v177 = v14 - 4 + v79; // 0x4025dc
                                                    *(int32_t *)(v177 + 4) = *(int32_t *)v177;
                                                    int32_t v178 = v177 - 4; // 0x4025e6
                                                    int32_t v179 = v10 - 1; // 0x4025e9
                                                    uint32_t v180 = v50; // 0x4025ec
                                                    // branch -> 0x4025e0
                                                    while (v180 < v179 + 1) {
                                                        // 0x4025e0
                                                        v177 = v178;
                                                        *(int32_t *)(v177 + 4) = *(int32_t *)v177;
                                                        v178 -= 4;
                                                        v179--;
                                                        v180 = v50;
                                                        // continue -> 0x4025e0
                                                    }
                                                    // 0x4025f0
                                                    g27 = v179;
                                                    *(int32_t *)(4 * v180 + v14) = g4;
                                                    v175 = v50;
                                                    // branch -> 0x4025fc
                                                    // 0x4025fc
                                                    v176 = v175 + 1;
                                                    g29 = v176;
                                                    g12 = v176;
                                                    // branch -> 0x40200c
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x4025fc
                                                v176 = v175 + 1;
                                                g29 = v176;
                                                g12 = v176;
                                                // branch -> 0x40200c
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                int32_t v181 = v1; // 0x40204a
                                                v92 = v181;
                                                v88 = v11;
                                                if (v181 >= 1) {
                                                    // 0x402055
                                                    g28 = v173;
                                                    v1 = 1;
                                                    v90 = v181;
                                                    v93 = 1;
                                                    v87 = v173;
                                                    // branch -> 0x401ec6
                                                    goto lab_0x401ec6;
                                                }
                                                // 0x40233d
                                                g5 = v15;
                                                g7 = v14;
                                                g3 = a2;
                                                _getopt_parse(v92, a2, a3, a4, (int32_t *)v51, (int32_t *)v17, v88);
                                                _getopt_parse(v92, a2, a3, a4, (int32_t *)v51, (int32_t *)v17, v88);
                                                // branch -> 0x40200c
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                            break;
                                        }
                                    }
                                  lab_0x401fae_2:
                                    // 0x401fae
                                    v89 = g31;
                                    g4 = v89;
                                    if (v89 == 0) {
                                        goto lab_0x401fbb;
                                    }
                                    goto lab_0x402016;
                                } else {
                                    v83 = v11;
                                    // 0x401fa0
                                    v84 = *a4;
                                    v85 = (int32_t)v84 | v10 & -256;
                                    if (v85 != 45) {
                                        goto lab_0x401fae_2;
                                    }
                                    // 0x402412
                                    g28 = NULL;
                                    g12 = v16 + 2;
                                    g25 = *v80;
                                    // branch -> 0x40200c
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            } else {
                                // 0x401fff
                                g12 = g29;
                                // branch -> 0x40200c
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    } else {
                        v54 = v76;
                    }
                }
                // 0x402260
                v64 = v55 - 1;
                g4 = v64;
                g27 = v64;
                v61 = v20;
                v68 = v61;
                v59 = v54;
                if (v64 >= v61) {
                    // 0x40226e
                    v57 = (int32_t)a3;
                    v65 = 4 * v55 + v57;
                    v66 = 4 * (v54 + v64) + v57;
                    g4 = v64 - 1;
                    *(int32_t *)v66 = *(int32_t *)(v65 - 4);
                    v71 = v65 - 4;
                    v72 = v66 - 4;
                    v58 = g4;
                    v62 = v20;
                    // branch -> 0x402280
                    while (v58 >= v62) {
                        // 0x402280
                        g4 = v58 - 1;
                        *(int32_t *)v72 = *(int32_t *)(v71 - 4);
                        v71 -= 4;
                        v72 -= 4;
                        v58 = g4;
                        v62 = v20;
                        // continue -> 0x402280
                    }
                    // 0x402290
                    g27 = v58;
                    v68 = v62;
                    v59 = v50;
                    // branch -> 0x402296
                }
                // 0x402296
                v70 = v68;
                v63 = v59;
                if (v59 >= 1) {
                    // 0x40229a
                    v67 = 4 * v68 + (int32_t)a3;
                    v69 = 0;
                    g4 = v69 + 1;
                    *(int32_t *)v67 = *(int32_t *)(4 * v69 + v52);
                    v56 = v67 + 4;
                    v60 = g4;
                    // branch -> 0x4022a2
                    while (v60 != v50) {
                        // 0x4022a2
                        v69 = v60;
                        g4 = v69 + 1;
                        *(int32_t *)v56 = *(int32_t *)(4 * v69 + v52);
                        v56 += 4;
                        v60 = g4;
                        // continue -> 0x4022a2
                    }
                    // 0x4022b2
                    v70 = v20;
                    v63 = v60;
                    // branch -> 0x4022b2
                }
                // 0x4022b2
                v49 = v63 + v70;
                v17 = v55;
                // branch -> 0x401e70
            } else {
                // 0x401e5f
                v49 = v48 + 1;
                v17 = v13;
                // branch -> 0x401e70
            }
            // 0x401e70
            g29 = v49;
            v14 = (int32_t)a3;
            v15 = (int32_t)a4;
            v11 = v12;
            // branch -> 0x401e70
            while (true) {
                // 0x401e70
                v16 = g30;
                v10 = v16 + 1;
                g30 = v10;
                if (v10 < a2) {
                    goto lab_0x401e86_3;
                }
                // 0x401fff
                g12 = g29;
                // branch -> 0x40200c
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // 0x401e40
        g28 = NULL;
        v18 = v7 - 1;
        g30 = v18;
        g29 = v18;
        g27 = v18;
        // branch -> 0x401e5f
        // 0x401e5f
        v17 = v13;
        // branch -> 0x401e70
        // 0x401e70
        g29 = v18 + 1;
        v14 = (int32_t)a3;
        v15 = (int32_t)a4;
        v11 = v12;
        // branch -> 0x401e70
        while (true) {
            // 0x401e70
            v16 = g30;
            v10 = v16 + 1;
            g30 = v10;
            if (v10 < a2) {
                goto lab_0x401e86_3;
            }
            // 0x401fff
            g12 = g29;
            // branch -> 0x40200c
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
    } else {
        // 0x402024
        g12 = 1;
        g26 = 0;
        // branch -> 0x401e40
    }
    // 0x401e40
    g28 = NULL;
    v18 = 0;
    g30 = v18;
    g29 = v18;
    g27 = v18;
    // branch -> 0x401e5f
    // 0x401e5f
    v17 = v13;
    // branch -> 0x401e70
    // 0x401e70
    g29 = v18 + 1;
    v14 = (int32_t)a3;
    v15 = (int32_t)a4;
    v11 = v12;
    // branch -> 0x401e70
    while (true) {
        // 0x401e70
        v16 = g30;
        v10 = v16 + 1;
        g30 = v10;
        if (v10 < a2) {
            goto lab_0x401e86_3;
        }
        // 0x401fff
        g12 = g29;
        // branch -> 0x40200c
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
}

// Address range: 0x4027d0 - 0x4027f6
int32_t _getopt_long_only(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4027d0
    int32_t v1;
    return _getopt_parse(2, a1, (char *)a2, (char *)a3, (int32_t *)a4, (int32_t *)a5, v1);
}

// Address range: 0x4027f7 - 0x4027ff
int32_t function_4027f7(int32_t a1) {
    // 0x4027f7
    return g7;
}

// Address range: 0x402800 - 0x402826
int32_t _getopt_long(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x402800
    int32_t v1;
    return _getopt_parse(1, a1, (char *)a2, (char *)a3, (int32_t *)a4, (int32_t *)a5, v1);
}

// Address range: 0x402827 - 0x40282f
int32_t function_402827(int32_t a1) {
    // 0x402827
    return g7;
}

// Address range: 0x4029d0 - 0x402a1f
int32_t ___pformat_putc(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(g6 + 4); // 0x4029d8
    int32_t * v2; // 0x4029f5_0
    int32_t * v3; // 0x402a0b_0
    int32_t result;
    int32_t v4;
    int32_t v5; // 0x4029ef
    if ((v1 & -256) != 0x2000) {
        // 0x4029e8
        if ((v1 & -0xff01) != 0) {
            // 0x402a00
            fputc(g1, (struct _IO_FILE *)*(int32_t *)g6);
            v3 = (int32_t *)(g6 + 24);
            *v3 = *v3 + 1;
            g3 = v4;
            return result;
        }
        // 0x4029ed
        v5 = *(int32_t *)(g6 + 24);
        *(char *)(v5 + *(int32_t *)g6) = (char)g1;
        // branch -> 0x4029f5
        // 0x4029f5
        v2 = (int32_t *)(g6 + 24);
        *v2 = *v2 + 1;
        g3 = v4;
        return result;
    }
    // 0x4029e0
    if (*(int32_t *)(g6 + 28) <= *(int32_t *)(g6 + 24)) {
        // 0x4029f5
        v2 = (int32_t *)(g6 + 24);
        *v2 = *v2 + 1;
        g3 = v4;
        return result;
    }
    // 0x4029e8
    if ((v1 & -0xff01) != 0) {
        // 0x402a00
        fputc(g1, (struct _IO_FILE *)*(int32_t *)g6);
        v3 = (int32_t *)(g6 + 24);
        *v3 = *v3 + 1;
        g3 = v4;
        return result;
    }
    // 0x4029ed
    v5 = *(int32_t *)(g6 + 24);
    *(char *)(v5 + *(int32_t *)g6) = (char)g1;
    // branch -> 0x4029f5
    // 0x4029f5
    v2 = (int32_t *)(g6 + 24);
    *v2 = *v2 + 1;
    g3 = v4;
    return result;
}

// Address range: 0x402a20 - 0x402aff
int32_t ___pformat_emit_radix_point(int32_t a1) {
    int32_t v1 = g1; // 0x402a29
    int32_t v2 = v1; // 0x402aa0
    int32_t ps;
    if (*(int32_t *)(v1 + 16) == -3) {
        // 0x402ac2
        ps = 0;
        int32_t wstr = *(int32_t *)localeconv(); // 0x402ad4
        int32_t pwc;
        int32_t v3 = mbrtowc((int16_t *)&pwc, (char *)wstr, 16, (struct _TYPEDEF___mbstate_t *)&ps); // 0x402adb
        if (v3 >= 1) {
            // 0x402ae9
            *(int16_t *)(v1 + 20) = (int16_t)pwc;
            // branch -> 0x402af1
        }
        // 0x402af1
        *(int32_t *)(v1 + 16) = v3;
        v2 = v1;
        // branch -> 0x402a35
    }
    // 0x402a35
    int32_t v4;
    int32_t v5;
    if (*(int16_t *)(v2 + 20) == 0) {
        // 0x402aa0
        g6 = v2;
        g1 = 46;
        int32_t v6;
        int32_t result = ___pformat_putc(v4, v6); // 0x402aa7
        g1 = result;
        g2 = v5;
        return result;
    }
    // 0x402a3c
    _alloca(v4);
    ps = 0;
    int32_t wc = *(int32_t *)(v1 + 20); // 0x402a60
    int32_t wstr2;
    int32_t v7 = wcrtomb((char *)&wstr2, (int16_t)wc, (struct _TYPEDEF___mbstate_t *)&ps); // 0x402a6a
    if (v7 < 1) {
        // 0x402ab4
        g6 = v1;
        g1 = 46;
        int32_t result2 = ___pformat_putc(v4, v7); // 0x402abb
        g1 = result2;
        // branch -> 0x402a91
        // 0x402a91
        g2 = v5;
        return result2;
    }
    // 0x402a79
    g1 = (int32_t)*(char *)(int32_t)&wstr2;
    g6 = v1;
    int32_t result3 = ___pformat_putc(v4, v7); // 0x402a87
    g1 = result3;
    // branch -> 0x402a80
    while (g3 != v7) {
        // 0x402a80
        g1 = (int32_t)*(char *)((int32_t)&wstr2 + g3);
        g6 = v1;
        result3 = ___pformat_putc(v4, v7);
        g1 = result3;
        // continue -> 0x402a80
    }
    // 0x402a91
    g2 = v5;
    return result3;
}

// Address range: 0x406140 - 0x40615f
int32_t ___freedtoa(int32_t a1) {
    int32_t v1 = a1 - 4; // 0x406144
    uint32_t v2 = *(int32_t *)v1; // 0x406144
    *(int32_t *)a1 = v2;
    *(int32_t *)(v1 + 8) = 1 << v2 % 32;
    int32_t result = ___Bfree_D2A(NULL); // 0x40615b
    g1 = result;
    return result;
}

// Address range: 0x406160 - 0x406190
int32_t ___rv_alloc_D2A(uint32_t a1) {
    // 0x406160
    g3 = 0;
    int32_t result; // 0x406189
    int32_t v1; // 0x406182
    if (a1 < 20) {
        // 0x40617e
        v1 = ___Balloc_D2A(0);
        *(int32_t *)v1 = g3;
        result = v1 + 4;
        g1 = result;
        return result;
    }
    int32_t v2 = 8; // 0x406174
    int32_t v3 = 1; // 0x406176
    // branch -> 0x406174
    while (v2 + 16 <= a1) {
        // 0x406174
        v2 *= 2;
        v3++;
        // continue -> 0x406174
    }
    // 0x40617e
    g3 = v3;
    // branch -> 0x40617e
    // 0x40617e
    v1 = ___Balloc_D2A(v3);
    *(int32_t *)v1 = g3;
    result = v1 + 4;
    g1 = result;
    return result;
}

// Address range: 0x406191 - 0x40619f
int32_t function_406191(void) {
    int32_t result = ___nrv_alloc_D2A(NULL, NULL, 0); // 0x406191
    g1 = result;
    return result;
}

// Address range: 0x4061a0 - 0x4061ef
int32_t ___nrv_alloc_D2A(char * a1, int32_t * a2, int32_t a3) {
    int32_t v1 = g7; // 0x4061a1
    int32_t v2 = g3; // 0x4061a2
    g7 = (int32_t)a1;
    int32_t result = ___rv_alloc_D2A(a3); // 0x4061b3
    unsigned char v3 = *(char *)g7; // 0x4061ba
    int32_t v4 = result; // ecx
    *(char *)result = v3;
    int32_t v5 = (int32_t)v3 | result & -256; // 0x4061c3
    int32_t v6; // 0x4061db
    if (v5 == 0) {
        // 0x4061db
        v6 = g5;
        if (v6 != 0) {
            // 0x4061df
            *(int32_t *)v6 = v4;
            // branch -> 0x4061e1
        }
        // 0x4061e1
        g3 = v2;
        g7 = v1;
        return result;
    }
    int32_t v7 = v4 + 1; // 0x4061d014
    v4 = v7;
    int32_t v8 = g7 + 1; // 0x4061d115
    unsigned char v9 = *(char *)v8; // 0x4061d117
    int32_t v10 = (int32_t)v9 | v5 & -256; // 0x4061d120
    *(char *)v7 = v9;
    if (v10 == 0) {
        // 0x4061db
        v6 = g5;
        if (v6 != 0) {
            // 0x4061df
            *(int32_t *)v6 = v4;
            // branch -> 0x4061e1
        }
        // 0x4061e1
        g3 = v2;
        g7 = v1;
        return result;
    }
    int32_t v11 = v4 + 1; // 0x4061d0
    v4 = v11;
    int32_t v12 = v8 + 1; // 0x4061d1
    unsigned char v13 = *(char *)v12; // 0x4061d1
    int32_t v14 = (int32_t)v13 | v10 & -256; // 0x4061d1
    *(char *)v11 = v13;
    while (v14 != 0) {
        // 0x4061d0
        v11 = v4 + 1;
        v4 = v11;
        v12++;
        v13 = *(char *)v12;
        v14 = (int32_t)v13 | v14 & -256;
        *(char *)v11 = v13;
        // continue -> 0x4061d0
    }
    // 0x4061db
    v6 = g5;
    if (v6 != 0) {
        // 0x4061df
        *(int32_t *)v6 = v4;
        // branch -> 0x4061e1
    }
    // 0x4061e1
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x406290 - 0x40634f
int32_t _dtoa_lock(int32_t a1) {
    int32_t v1 = g3; // 0x406291
    int32_t v2 = (int32_t)g32;
    int32_t v3 = v2; // 0x4062b917
    int32_t v4;
    int32_t v5;
    void (**v6)();
    int32_t result2; // 0x4062c3
    int32_t result; // 0x406327
    int32_t v7; // 0x4062be
    switch (v2) {
        case 2: {
            // 0x406311
            EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * g1 + (int32_t)&g33));
            result = v4;
            g1 = result;
            g3 = v1;
            g7 = v5;
            return result;
        }
        case 0: {
            // 0x4062c7
            int32_t v8; // ebx
            int32_t lpCriticalSection; // 0x4062e3
            switch (InterlockedExchange((int32_t *)&g32, 1)) {
                default: {
                    // 0x406330
                    v3 = (int32_t)g32;
                    // branch -> 0x4062b9
                    // 0x4062b9
                    if (v3 == 1) {
                        // 0x4062a7
                        // branch -> 0x4062a7
                        while (true) {
                            // 0x4062a7
                            Sleep(1);
                            v6 = g32;
                            int32_t v9 = (int32_t)v6;
                            if (v6 != (void (**)())1) {
                                v7 = v9;
                                // break (via goto) -> 0x4062be
                                goto lab_0x4062be;
                            }
                            // continue -> 0x4062a7
                        }
                    }
                    // 0x4062be
                    if (v3 != 2) {
                        // 0x4062c3
                        result2 = v4;
                        g1 = result2;
                        g3 = v1;
                        g7 = v5;
                        return result2;
                    }
                    // 0x406311
                    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * g1 + (int32_t)&g33));
                    result = v4;
                    g1 = result;
                    g3 = v1;
                    g7 = v5;
                    return result;
                }
                case 0: {
                    // 0x4062db
                    v8 = (int32_t)&g33;
                    lpCriticalSection = (int32_t)&g33;
                    // branch -> 0x4062e0
                    break;
                }
                case 2: {
                    // 0x406337
                    g32 = (void (**)())2;
                    // branch -> 0x406311
                    // 0x406311
                    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * g1 + (int32_t)&g33));
                    result = v4;
                    g1 = result;
                    g3 = v1;
                    g7 = v5;
                    return result;
                }
            }
            while (true) {
                // 0x4062e0
                InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)lpCriticalSection);
                int32_t v10 = v8 + 24; // 0x4062e9
                v8 = v10;
                if (v10 == 0x40a220) {
                    // break (via goto) -> 0x4062f7
                    goto lab_0x4062f7;
                }
                lpCriticalSection = v10;
                // continue -> 0x4062e0
            }
          lab_0x4062f7:
            // 0x4062f7
            atexit((void (**)())_dtoa_lock_cleanup);
            g32 = (void (**)())2;
            // branch -> 0x406311
            // 0x406311
            EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * g1 + (int32_t)&g33));
            result = v4;
            g1 = result;
            g3 = v1;
            g7 = v5;
            return result;
        }
    }
    // 0x4062b9
    v7 = v3;
    if (v3 != 1) {
      lab_0x4062be:
        // 0x4062be
        if (v7 != 2) {
            // 0x4062c3
            result2 = v4;
            g1 = result2;
            g3 = v1;
            g7 = v5;
            return result2;
        }
        // 0x406311
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * g1 + (int32_t)&g33));
        result = v4;
        g1 = result;
        g3 = v1;
        g7 = v5;
        return result;
    }
    // 0x4062a7
    Sleep(1);
    v6 = g32;
    // branch -> 0x4062a7
    while (v6 == (void (**)())1) {
        // 0x4062a7
        Sleep(1);
        v6 = g32;
        // continue -> 0x4062a7
    }
    // 0x4062be
    if ((int32_t)v6 != 2) {
        // 0x4062c3
        result2 = v4;
        g1 = result2;
        g3 = v1;
        g7 = v5;
        return result2;
    }
    // 0x406311
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * g1 + (int32_t)&g33));
    result = v4;
    g1 = result;
    g3 = v1;
    g7 = v5;
    return result;
}

// Address range: 0x406350 - 0x40638f
int32_t _dtoa_lock_cleanup(void) {
    // 0x406350
    int32_t result;
    int32_t v1;
    if (InterlockedExchange((int32_t *)&g32, 3) != 2) {
        // 0x406367
        g1 = result;
        g3 = v1;
        return result;
    }
    // 0x406370
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)(int32_t)&g33);
    int32_t lpCriticalSection = (int32_t)&g33 + 24; // 0x40637e
    // branch -> 0x406375
    while (lpCriticalSection != 0x40a220) {
        // 0x406375
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)lpCriticalSection);
        lpCriticalSection += 24;
        // continue -> 0x406375
    }
    // 0x40638c
    g1 = result;
    g3 = v1;
    return result;
}

// Address range: 0x406390 - 0x4063bf
int32_t _dtoa_unlock(int32_t a1) {
    // 0x406390
    if (g32 != (void (**)())2) {
        // 0x40639c
        return g1;
    }
    int32_t lpCriticalSection = 24 * g1 + (int32_t)&g33; // 0x4063a6
    g1 = lpCriticalSection;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)lpCriticalSection);
    return lpCriticalSection;
}

// Address range: 0x4063c0 - 0x4063f9
int32_t ___Bfree_D2A(int32_t * a1) {
    // 0x4063c0
    g3 = (int32_t)a1;
    int32_t result;
    if (a1 == NULL) {
        // 0x4063f0
        return result;
    }
    // 0x4063cc
    g1 = 0;
    _dtoa_lock(result);
    int32_t v1 = *(int32_t *)(g3 + 4); // 0x4063d3
    int32_t v2 = *(int32_t *)(4 * v1 + (int32_t)&g34); // 0x4063d6
    *(int32_t *)g3 = v2;
    g1 = 0;
    *(int32_t *)(4 * v1 + (int32_t)&g34) = g3;
    int32_t v3;
    return _dtoa_unlock(v3);
}

// Address range: 0x4063fa - 0x4063ff
int32_t function_4063fa(int32_t a1) {
    // 0x4063fa
    return g5;
}

// Address range: 0x406400 - 0x40649f
int32_t ___Balloc_D2A(int32_t a1) {
    int32_t v1 = g3; // 0x406402
    g1 = 0;
    _dtoa_lock(v1);
    int32_t * v2 = (int32_t *)(4 * g7 + (int32_t)&g34); // 0x40640e_0
    int32_t v3 = *v2; // 0x40640e
    int32_t result = v3; // ebx
    if (v3 == 0) {
        uint32_t v4 = g7 % 32; // 0x406447
        int32_t v5 = 1;
        int32_t v6 = 3; // 0x406451
        if (v4 != 0) {
            // if_406447_0_true
            v5 = 1 << v4;
            v6 = ((4 << v4) + 27) / 8;
            // branch -> after_if_406447_0
        }
        int32_t v7 = *(int32_t *)&g15; // 0x406449
        int32_t mem; // 0x40648a_3
        if ((v7 - 0x40a260) / 8 + v6 > 288) {
            // 0x40647f
            mem = (int32_t)malloc(8 * v6);
            result = mem;
            // branch -> 0x406477
        } else {
            // 0x40646d
            result = v7;
            *(int32_t *)&g15 = 8 * v6 + v7;
            mem = v7;
            // branch -> 0x406477
        }
        // 0x406477
        *(int32_t *)(mem + 4) = g7;
        *(int32_t *)(result + 8) = v5;
        // branch -> 0x406422
    } else {
        // 0x406419
        *v2 = *(int32_t *)v3;
        // branch -> 0x406422
    }
    // 0x406422
    g1 = 0;
    _dtoa_unlock(v1);
    *(int32_t *)(result + 16) = 0;
    *(int32_t *)(result + 12) = 0;
    g1 = result;
    g3 = v1;
    int32_t v8;
    g5 = v8;
    return result;
}

// Address range: 0x406880 - 0x40689f
int32_t ___i2b_D2A(int32_t a1) {
    int32_t result = ___Balloc_D2A(1); // 0x406885
    g1 = result;
    *(int32_t *)(result + 20) = a1;
    *(int32_t *)(result + 16) = 1;
    return result;
}

// Address range: 0x406da0 - 0x406def
int32_t ___trailz_D2A(int32_t a1) {
    int32_t v1 = a1 + 20; // 0x406dab
    uint32_t v2 = 4 * *(int32_t *)(a1 + 16) + v1; // 0x406dae
    int32_t result = 0; // 0x406dd0
    if (v1 >= v2) {
        // 0x406dd0
        g1 = result;
        return result;
    }
    int32_t * v3 = (int32_t *)v1; // 0x406db6_0
    int32_t result2; // 0x406ddb
    int32_t v4; // 0x406ddb
    if (*v3 != 0) {
        int32_t v5 = *v3; // 0x406dd5
        if (v5 == 0) {
            // after_if_406dd8_0
            result2 = 0;
            g1 = result2;
            return result2;
        }
        // if_406dd8_0_false
        v4 = llvm_cttz_i32(v5, false);
        // branch -> after_if_406dd8_0
        // after_if_406dd8_0
        result2 = v4;
        g1 = result2;
        return result2;
    }
    int32_t v6 = 0; // 0x406dc9
    int32_t v7; // 0x406dc9
    int32_t v8; // 0x406dc0
    while (true) {
        int32_t v9 = v1 + 4; // 0x406dc6
        v7 = v6 + 32;
        if (v2 <= v9) {
            result = v7;
            // 0x406dd0
            g1 = result;
            return result;
        }
        // 0x406dc0
        v8 = *(int32_t *)v9;
        if (v8 != 0) {
            // break -> if_406dd8_0_false
            break;
        }
        v6 = v7;
        v1 = v9;
        // continue -> 0x406dc6
    }
    // if_406dd8_0_false
    v4 = llvm_cttz_i32(v8, false);
    // branch -> after_if_406dd8_0
    // after_if_406dd8_0
    result2 = v4 + v7;
    g1 = result2;
    return result2;
}

// Address range: 0x406e78 - 0x406e7b
int32_t __get_output_format(void) {
    // 0x406e78
    g1 = 0;
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void * __cdecl _alloca(_In_ size_t Size);
// int _snprintf(char * const Buffer, _In_ size_t const BufferCount, _In_z_ char const * const Format, ...);
// size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict p);
// char * strcasestr(char * haystack, const char * needle);
// size_t wcrtomb(char * restrict s, wchar_t wc, mbstate_t * restrict ps);

// --------------- Dynamically Linked Functions ---------------

// void abort(void);
// int atexit(void(* func)(void));
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputc(int c, FILE * stream);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// char * getenv(const char * name);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// unsigned InterlockedExchange(_Inout_ unsigned volatile * Target, _In_ unsigned Value);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// struct lconv * localeconv(void);
// void * malloc(size_t size);
// void * memset(void * s, int c, size_t n);
// void qb_blank_flash(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
// void qb_describe_error(int32_t a1);
// void qb_get_version(int32_t a1, int32_t a2);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// LSTATUS RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// BOOL SetupDiClassGuidsFromNameA(_In_ PCSTR ClassName, LPGUID ClassGuidList, _In_ DWORD ClassGuidListSize, _Out_ PDWORD RequiredSize);
// BOOL SetupDiDestroyDeviceInfoList(_In_ HDEVINFO DeviceInfoSet);
// BOOL SetupDiEnumDeviceInfo(_In_ HDEVINFO DeviceInfoSet, _In_ DWORD MemberIndex, _Out_ PSP_DEVINFO_DATA DeviceInfoData);
// HDEVINFO SetupDiGetClassDevsA(_In_opt_ const GUID * ClassGuid, _In_opt_ PCSTR Enumerator, _In_opt_ HWND hwndParent, _In_ DWORD Flags);
// BOOL SetupDiGetDeviceRegistryPropertyA(_In_ HDEVINFO DeviceInfoSet, _In_ PSP_DEVINFO_DATA DeviceInfoData, _In_ DWORD Property, _Out_opt_ PDWORD PropertyRegDataType, PBYTE PropertyBuffer, _In_ DWORD PropertyBufferSize, _Out_opt_ PDWORD RequiredSize);
// HKEY SetupDiOpenDevRegKey(_In_ HDEVINFO DeviceInfoSet, _In_ PSP_DEVINFO_DATA DeviceInfoData, _In_ DWORD Scope, _In_ DWORD HwProfile, _In_ DWORD KeyType, _In_ REGSAM samDesired);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// unsigned long int strtoul(const char * restrict nptr, char ** restrict endptr, int base);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_cttz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.2.1)
// Detected language: C
// Detected functions: 36
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-05-27 17:16:43
